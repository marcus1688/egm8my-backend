const express = require("express");
const bcrypt = require("bcrypt");
const {
  User,
  userLog,
  adminUserWalletLog,
  GameDataLog,
} = require("../models/users.model");
const TelegramBot = require("node-telegram-bot-api");
const UserBankList = require("../models/userbanklist.model");
const promotion = require("../models/promotion.model");
const { adminUser, adminLog } = require("../models/adminuser.model");
const router = express.Router();
const Deposit = require("../models/deposit.model");
const vip = require("../models/vip.model");
const Withdraw = require("../models/withdraw.model");
const { RebateLog } = require("../models/rebate.model");
const UserWalletCashOut = require("../models/userwalletcashout.model");
const jwt = require("jsonwebtoken");
const {
  generateToken,
  generateGameToken,
  setCookie,
  authenticateToken,
  generateRefreshToken,
  handleLoginSuccess,
  setRefreshCookie,
  clearCookie,
} = require("../auth/auth");
const SlotLivePPModal = require("../models/slot_live_pp.model");
const SlotLiveAGModal = require("../models/slot_live_ag.model");
const SlotLiveGSCModal = require("../models/slot_live_gsc.model");
const SlotJokerModal = require("../models/slot_joker.model");
const SlotJiliModal = require("../models/slot_jili.model");
const SlotHabaneroModal = require("../models/slot_habanero.model");
const SlotKiss918H5Modal = require("../models/slot_kiss918.model");
const SlotCQ9Modal = require("../models/slot_cq9.model");
const SlotLive22Modal = require("../models/slot_live22.model");
const SlotUUSlotModal = require("../models/slot_uuslot.model");
const LiveCT855Modal = require("../models/live_ct855.model");
const SlotNextSpinModal = require("../models/slot_nextspin.model");
const SlotLFC888Modal = require("../models/slot_lfc888.model");
const SlotMega888H5Modal = require("../models/slot_mega888h5.model");
const LotteryAP95Modal = require("../models/lottery_ap95.mode");
const PlaytechGameModal = require("../models/slot_playtech.model");
const slotGW99Modal = require("../models/slot_gw99.model");
const SlotSpadeGamingModal = require("../models/slot_spadegaming.model");
const SlotFachaiModal = require("../models/slot_fachai.model");
const LiveSaGamingModal = require("../models/live_sagaming.model");
const SlotLiveMicroGamingModal = require("../models/slot_microgaming.model");
const SlotHacksawModal = require("../models/slot_hacksaw.model");
const SportCMDModal = require("../models/sport_cmd.model");

const { authenticateAdminToken } = require("../auth/adminAuth");
const geoip = require("geoip-lite");
const BankList = require("../models/banklist.model");
const BankTransactionLog = require("../models/banktransactionlog.model");

const UserWalletLog = require("../models/userwalletlog.model");
const Bonus = require("../models/bonus.model");
const querystring = require("querystring");
const GameWalletLog = require("../models/gamewalletlog.model");
const LuckySpinSetting = require("../models/luckyspinsetting.model");
const { updateKioskBalance } = require("../services/kioskBalanceService");
const kioskbalance = require("../models/kioskbalance.model");
const axios = require("axios");
const crypto = require("crypto");
const moment = require("moment");
const dotenv = require("dotenv");
const nodemailer = require("nodemailer");
const mg = require("nodemailer-mailgun-transport");
const { v4: uuidv4 } = require("uuid");
const messagebird = require("messagebird");
const QRCode = require("qrcode");
const rateLimit = require("express-rate-limit");
const loginLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1Â∞èÊó∂
  max: 30, // ÈôêÂà∂ÊØè‰∏™IPÂú®1Â∞èÊó∂ÂÜÖÊúÄÂ§ö30Ê¨°Â∞ùËØï
  message: "Too many requests, please try again later.",
  standardHeaders: true,
  legacyHeaders: false,
  skipFailedRequests: false,
  skipSuccessfulRequests: false,
  handler: (req, res, next, options) => {
    const clientIp = req.headers["x-forwarded-for"] || req.ip;
    const clientIpTrimmed = clientIp.split(",")[0].trim();
    const origin = req.headers.origin || "Unknown";

    console.log(
      `Login Rate Limit Exceeded - IP: ${clientIpTrimmed}, Origin: ${origin}, Path: ${
        req.path
      }, Time: ${new Date().toISOString()}`
    );

    res.status(options.statusCode).send(options.message);
  },
});

dotenv.config();

router.use(express.json());

async function sendTelegramNotification(userData) {
  const token = process.env.TELEGRAM_BOT_TOKEN;
  const chatId = process.env.ADMIN_TELEGRAM_CHAT_ID;
  if (!token || !chatId) {
    console.log("Telegram not configured");
    return false;
  }
  try {
    const bot = new TelegramBot(token);
    const duplicateWarning = userData.duplicateIP
      ? "üö® *DUPLICATE IP DETECTED* üö®\n\n"
      : "";
    const message = `
${duplicateWarning}üÜï *NEW USER REGISTRATION*
üë§ *Username:* \`${userData.username}\`
üìù *Full Name:* ${userData.fullname}
üì± *Phone:* \`${userData.phonenumber}\`
üåê *IP Address:* \`${userData.registerIp}\`
üë• *Referred by:* ${userData.referralBy || "Direct Registration"}
‚è∞ *Time:* ${new Date().toLocaleString("en-MY", {
      timeZone: "Asia/Kuala_Lumpur",
    })}
${
  userData.duplicateIP
    ? "‚úÖ *Registration completed successfully*"
    : "‚úÖ *Registration completed successfully*"
}
    `;
    await bot.sendMessage(chatId, message, {
      parse_mode: "Markdown",
      disable_web_page_preview: true,
    });
    console.log("‚úÖ Telegram notification sent");
    return true;
  } catch (error) {
    console.error("‚ùå Telegram notification failed:", error.message);
    return false;
  }
}

async function generateUniqueReferralCode() {
  let referralCode;
  let isUnique = false;

  while (!isUnique) {
    referralCode = crypto.randomBytes(4).toString("hex");
    const existingUser = await User.findOne({ referralCode: referralCode });
    if (!existingUser) {
      isUnique = true;
    }
  }
  return referralCode;
}

const generateReferralLink = (referralCode) => {
  return `${process.env.REFERRAL_URL}${referralCode}`;
};

function formatSeconds(seconds) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(
    2,
    "0"
  )}:${String(secs).padStart(2, "0")}`;
}

function calculateProcessingTime(createdAtDate) {
  const approvedAt = new Date();
  const createdAt = new Date(createdAtDate);
  let timeDiff = approvedAt.getTime() - createdAt.getTime();

  let seconds = Math.floor((timeDiff / 1000) % 60);
  let minutes = Math.floor((timeDiff / (1000 * 60)) % 60);
  let hours = Math.floor((timeDiff / (1000 * 60 * 60)) % 24);

  return `${hours.toString().padStart(2, "0")}:${minutes
    .toString()
    .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
}

function parseTimeToSeconds(timeString) {
  const [hours, minutes, seconds] = timeString.split(":").map(Number);
  return hours * 3600 + minutes * 60 + seconds;
}

function formatTime(totalSeconds) {
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = Math.floor(totalSeconds % 60);

  return `${hours.toString().padStart(2, "0")}:${minutes
    .toString()
    .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
}
//Main function for averageprocessingtime
async function updateAverageProcessingTime(
  username,
  newProcessTime,
  transactionType
) {
  const admin = await adminUser.findOne({ username: username });
  if (!admin) {
    return res.status(200).json({ message: "Admin not found!" });
  }

  const newProcessTimeInSeconds = parseTimeToSeconds(newProcessTime);

  if (transactionType === "deposit") {
    admin.totalDepositProcessingTime += newProcessTimeInSeconds;
    admin.depositTransactionCount += 1;
    if (admin.depositTransactionCount > 0) {
      const averageSeconds =
        admin.totalDepositProcessingTime / admin.depositTransactionCount;
      admin.averageDepositProcessingTime = formatTime(averageSeconds);
    }
  } else if (transactionType === "withdrawal") {
    admin.totalWithdrawalProcessingTime += newProcessTimeInSeconds;
    admin.withdrawalTransactionCount += 1;
    if (admin.withdrawalTransactionCount > 0) {
      const averageSeconds =
        admin.totalWithdrawalProcessingTime / admin.withdrawalTransactionCount;
      admin.averageWithdrawalProcessingTime = formatTime(averageSeconds);
    }
  }

  await admin.save();
}

async function adminLogAttempt(company, username, fullname, clientIp, remark) {
  await adminLog.create({
    company,
    username,
    fullname,
    loginTime: new Date(),
    ip: clientIp,
    remark,
  });
}

async function userLogAttempt(
  username,
  fullname,
  phonenumber,
  source,
  clientIp,
  ipcountry,
  ipcity,
  remark
) {
  await userLog.create({
    username,
    fullname,
    phonenumber,
    source,
    ipaddress: clientIp,
    ipcountry,
    ipcity,
    loginTime: new Date(),
    remark,
  });
}

async function updateUserReferral(
  userId,
  referralByUsername,
  adminUsername,
  adminFullname,
  clientIp
) {
  try {
    const user = await User.findById(userId);
    if (!user) {
      return {
        success: false,
        message: {
          en: "User not found",
          zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
        },
      };
    }
    const originalReferrer =
      user.referralBy && user.referralBy.username
        ? user.referralBy.username
        : "none";
    if (!referralByUsername) {
      if (user.referralBy && user.referralBy.user_id) {
        await User.updateOne(
          { _id: user.referralBy.user_id },
          { $pull: { referrals: { user_id: user._id } } }
        );
      }
      user.referralBy = null;
      await user.save();
      await adminLog.create({
        username: adminUsername,
        fullname: adminFullname,
        loginTime: new Date(),
        ip: clientIp,
        remark: `Cleared referral relationship for user: ${user.username} (previously referred by: ${originalReferrer})`,
      });
      return {
        success: true,
        message: {
          en: "Referral relationship cleared successfully",
          zh: "Êé®ËçêÂÖ≥Á≥ªÂ∑≤ÊàêÂäüÊ∏ÖÈô§",
        },
      };
    }
    const referrer = await User.findOne({ username: referralByUsername });
    if (!referrer) {
      return {
        success: false,
        message: {
          en: "Referrer not found",
          zh: "Êâæ‰∏çÂà∞Êé®Ëçê‰∫∫",
        },
      };
    }
    if (referrer._id.toString() === userId) {
      return {
        success: false,
        message: {
          en: "Users cannot refer themselves",
          zh: "Áî®Êà∑‰∏çËÉΩÊé®ËçêËá™Â∑±",
        },
      };
    }
    if (user.referralBy && user.referralBy.user_id) {
      await User.updateOne(
        { _id: user.referralBy.user_id },
        { $pull: { referrals: { user_id: user._id } } }
      );
    }
    user.referralBy = {
      user_id: referrer._id,
      username: referrer.username,
    };
    await user.save();
    const referralExists = await User.findOne({
      _id: referrer._id,
      "referrals.user_id": user._id,
    });
    if (!referralExists) {
      await User.updateOne(
        { _id: referrer._id },
        {
          $push: {
            referrals: {
              user_id: user._id,
              username: user.username,
            },
          },
        }
      );
    }
    await adminLog.create({
      username: adminUsername,
      fullname: adminFullname,
      loginTime: new Date(),
      ip: clientIp,
      remark: `Changed referral for user: ${user.username} from ${originalReferrer} to ${referrer.username}`,
    });
    return {
      success: true,
      message: {
        en: "User referral updated successfully",
        zh: "Áî®Êà∑Êé®ËçêÂÖ≥Á≥ªÊõ¥Êñ∞ÊàêÂäü",
      },
    };
  } catch (error) {
    console.error("Error updating referral relationship:", error);
    return {
      success: false,
      message: {
        en: "Internal server error when updating referral",
        zh: "Êõ¥Êñ∞Êé®ËçêÂÖ≥Á≥ªÊó∂ÂèëÁîüÂÜÖÈÉ®ÊúçÂä°Âô®ÈîôËØØ",
      },
      error: error.message,
    };
  }
}

// Register User
// router.post("/api/register", async (req, res) => {
//   const {
//     username,
//     fullname,
//     dob,
//     password,
//     phonenumber,
//     referralCode,
//     isPhoneVerified,
//   } = req.body;

//   if (!username || !password || !fullname) {
//     return res.status(200).json({
//       success: false,
//       message: {
//         en: "Please fill in all required fields",
//         zh: "ËØ∑Â°´ÂÜôÊâÄÊúâÂøÖÂ°´Â≠óÊÆµ",
//         ms: "Sila isi semua ruangan yang diperlukan",
//       },
//     });
//   }

//   if (!/^[a-zA-Z\s]+$/.test(fullname)) {
//     return res.status(200).json({
//       success: false,
//       message: {
//         en: "Full name can only contain letters and spaces",
//         zh: "ÂÖ®ÂêçÂè™ËÉΩÂåÖÂê´Â≠óÊØçÂíåÁ©∫Ê†º",
//         ms: "Nama penuh hanya boleh mengandungi huruf dan ruang",
//       },
//     });
//   }

//   if (!/^[a-zA-Z0-9]+$/.test(username)) {
//     return res.status(200).json({
//       success: false,
//       message: {
//         en: "Username can only contain letters and numbers",
//         zh: "Áî®Êà∑ÂêçÂè™ËÉΩÂåÖÂê´Â≠óÊØçÂíåÊï∞Â≠ó",
//         ms: "Nama pengguna hanya boleh mengandungi huruf dan nombor",
//       },
//     });
//   }

//   if (username.length < 6) {
//     return res.status(200).json({
//       success: false,
//       message: {
//         en: "Username must be at least 6 characters long",
//         zh: "Áî®Êà∑ÂêçÈïøÂ∫¶ÂøÖÈ°ªËá≥Â∞ë‰∏∫6‰∏™Â≠óÁ¨¶",
//         ms: "Nama pengguna mestilah sekurang-kurangnya 6 aksara",
//       },
//     });
//   }

//   if (password.length < 8) {
//     return res.status(200).json({
//       success: false,
//       message: {
//         en: "Password must be at least 8 characters long",
//         zh: "ÂØÜÁ†ÅÈïøÂ∫¶ÂøÖÈ°ªËá≥Â∞ë‰∏∫8‰∏™Â≠óÁ¨¶",
//         ms: "Kata laluan mestilah sekurang-kurangnya 8 aksara",
//       },
//     });
//   }
//   const normalizedUsername = username.toLowerCase();
//   const cleanedFullname = fullname.trim().replace(/\s+/g, " ");
//   const normalizedFullname = cleanedFullname.toLowerCase();
//   let clientIp = req.headers["x-forwarded-for"] || req.ip;
//   clientIp = clientIp.split(",")[0].trim();
//   console.log("=== IPÊ£ÄÊµãË∞ÉËØï ===");
//   console.log("ÂΩìÂâçÊ≥®ÂÜåÁî®Êà∑Âêç:", normalizedUsername);
//   console.log("ÂΩìÂâçÁî®Êà∑IP:", clientIp);
//   try {
//     const existingUser = await User.findOne({
//       $or: [{ fullname: new RegExp(`^${normalizedFullname}$`, "i") }],
//     });
//     if (existingUser) {
//       return res.status(200).json({
//         success: false,
//         message: {
//           en: "full name is already registered. Please try a different one.",
//           zh: "ÂÖ®ÂêçÂ∑≤Ë¢´Ê≥®ÂÜå„ÄÇËØ∑Â∞ùËØï‰ΩøÁî®ÂÖ∂‰ªñÂêçÁß∞„ÄÇ",
//           ms: "Nama penuh sudah didaftarkan. Sila cuba nama yang lain.",
//         },
//       });
//     }
//     const existingUsername = await User.findOne({
//       username: normalizedUsername,
//     });
//     if (existingUsername) {
//       return res.status(200).json({
//         success: false,
//         message: {
//           en: "Username is already taken. Please choose a different one.",
//           zh: "Áî®Êà∑ÂêçÂ∑≤Ë¢´Âç†Áî®„ÄÇËØ∑ÈÄâÊã©ÂÖ∂‰ªñÁî®Êà∑Âêç„ÄÇ",
//           ms: "Nama pengguna sudah diambil. Sila pilih yang lain.",
//         },
//       });
//     }
//     const existingPhoneNumber = await User.findOne({
//       phonenumber: phonenumber,
//     });

//     if (existingPhoneNumber) {
//       return res.status(200).json({
//         success: false,
//         message: {
//           en: "Phone number is already registered. Please use a different number.",
//           zh: "ÊâãÊú∫Âè∑Á†ÅÂ∑≤Ë¢´Ê≥®ÂÜå„ÄÇËØ∑‰ΩøÁî®ÂÖ∂‰ªñÂè∑Á†Å„ÄÇ",
//           ms: "Nombor telefon sudah didaftarkan. Sila gunakan nombor yang berbeza.",
//         },
//       });
//     }
//     console.log("ÂºÄÂßãÊ£ÄÊü•IPÈáçÂ§ç...");
//     const userWithSameIp = await User.findOne({
//       $or: [{ lastLoginIp: clientIp }, { registerIp: clientIp }],
//     });

//     if (userWithSameIp) {
//       console.log("ÊâæÂà∞Áõ∏ÂêåIPÁöÑÁî®Êà∑:");
//       console.log("- ÂåπÈÖçÁî®Êà∑Âêç:", userWithSameIp.username);
//       console.log("- ÂåπÈÖçÁî®Êà∑ID:", userWithSameIp._id);
//       console.log("- ËØ•Áî®Êà∑Ê≥®ÂÜåIP:", userWithSameIp.registerIp);
//       console.log("- ËØ•Áî®Êà∑ÊúÄÂêéÁôªÂΩïIP:", userWithSameIp.lastLoginIp);
//       console.log(
//         "- IPÂåπÈÖçÂéüÂõ†:",
//         userWithSameIp.registerIp === clientIp ? "Ê≥®ÂÜåIPÁõ∏Âêå" : "ÁôªÂΩïIPÁõ∏Âêå"
//       );
//     } else {
//       console.log("Êú™ÊâæÂà∞Áõ∏ÂêåIPÁöÑÁî®Êà∑");
//     }

//     const isDuplicateIP = !!userWithSameIp;
//     console.log("duplicateIPÊ†áËÆ∞ÁªìÊûú:", isDuplicateIP);
//     console.log("=== IPÊ£ÄÊµãÁªìÊùü ===");

//     const salt = await bcrypt.genSalt(10);
//     const hashedPassword = await bcrypt.hash(password, salt);
//     const newReferralCode = await generateUniqueReferralCode();
//     const referralLink = generateReferralLink(newReferralCode);
//     const referralQrCode = await QRCode.toDataURL(referralLink);

//     let referralBy = null;
//     if (referralCode) {
//       const referrer = await User.findOne({ referralCode: referralCode });
//       if (referrer) {
//         referralBy = {
//           user_id: referrer._id,
//           username: referrer.username,
//         };
//       }
//     }

//     const newUser = await User.create({
//       username: normalizedUsername,
//       fullname: normalizedFullname,
//       password: hashedPassword,
//       dob,
//       phonenumber,
//       registerIp: clientIp,
//       referralLink,
//       referralCode: newReferralCode,
//       referralQrCode,
//       referralBy,
//       duplicateIP: isDuplicateIP,
//       isPhoneVerified: isPhoneVerified,
//       viplevel: "Bronze",
//     });

//     if (referralBy) {
//       await User.findByIdAndUpdate(referralBy.user_id, {
//         $push: {
//           referrals: {
//             user_id: newUser._id,
//             username: newUser.username,
//           },
//         },
//       });
//     }
//     res.status(200).json({
//       success: true,
//       message: {
//         en: "User created successfully",
//         zh: "Áî®Êà∑ÂàõÂª∫ÊàêÂäü",
//         ms: "Pengguna berjaya dicipta",
//       },
//     });
//   } catch (error) {
//     console.error("Error occurred while creating user:", error);
//     res.status(200).json({
//       success: false,
//       message: {
//         en: "Registration failed due to a system error. Please try again later",
//         zh: "Áî±‰∫éÁ≥ªÁªüÈîôËØØÔºåÊ≥®ÂÜåÂ§±Ë¥•„ÄÇËØ∑Á®çÂêéÂÜçËØï",
//         ms: "Pendaftaran gagal kerana ralat sistem. Sila cuba lagi kemudian",
//       },
//     });
//   }
// });

// Register User
router.post("/api/register", async (req, res) => {
  const {
    username,
    fullname,
    dob,
    password,
    phonenumber,
    referralCode,
    isPhoneVerified,
  } = req.body;

  if (!username || !password || !fullname) {
    return res.status(200).json({
      success: false,
      message: {
        en: "Please fill in all required fields",
        zh: "ËØ∑Â°´ÂÜôÊâÄÊúâÂøÖÂ°´Â≠óÊÆµ",
        ms: "Sila isi semua ruangan yang diperlukan",
      },
    });
  }

  if (!/^[a-zA-Z\s]+$/.test(fullname)) {
    return res.status(200).json({
      success: false,
      message: {
        en: "Full name can only contain letters and spaces",
        zh: "ÂÖ®ÂêçÂè™ËÉΩÂåÖÂê´Â≠óÊØçÂíåÁ©∫Ê†º",
        ms: "Nama penuh hanya boleh mengandungi huruf dan ruang",
      },
    });
  }

  if (!/^[a-zA-Z0-9]+$/.test(username)) {
    return res.status(200).json({
      success: false,
      message: {
        en: "Username can only contain letters and numbers",
        zh: "Áî®Êà∑ÂêçÂè™ËÉΩÂåÖÂê´Â≠óÊØçÂíåÊï∞Â≠ó",
        ms: "Nama pengguna hanya boleh mengandungi huruf dan nombor",
      },
    });
  }

  if (username.length < 6) {
    return res.status(200).json({
      success: false,
      message: {
        en: "Username must be at least 6 characters long",
        zh: "Áî®Êà∑ÂêçÈïøÂ∫¶ÂøÖÈ°ªËá≥Â∞ë‰∏∫6‰∏™Â≠óÁ¨¶",
        ms: "Nama pengguna mestilah sekurang-kurangnya 6 aksara",
      },
    });
  }

  if (password.length < 8) {
    return res.status(200).json({
      success: false,
      message: {
        en: "Password must be at least 8 characters long",
        zh: "ÂØÜÁ†ÅÈïøÂ∫¶ÂøÖÈ°ªËá≥Â∞ë‰∏∫8‰∏™Â≠óÁ¨¶",
        ms: "Kata laluan mestilah sekurang-kurangnya 8 aksara",
      },
    });
  }

  const normalizedUsername = username.toLowerCase();
  const cleanedFullname = fullname.trim().replace(/\s+/g, " ");
  const normalizedFullname = cleanedFullname.toLowerCase();
  let clientIp = req.headers["x-forwarded-for"] || req.ip;
  clientIp = clientIp.split(",")[0].trim();

  console.log("=== Ê≥®ÂÜåIPÊ£ÄÊµãË∞ÉËØï ===");
  console.log("ÂΩìÂâçÊ≥®ÂÜåÁî®Êà∑Âêç:", normalizedUsername);
  console.log("ÂΩìÂâçÁî®Êà∑IP:", clientIp);

  try {
    const existingUser = await User.findOne({
      $or: [{ fullname: new RegExp(`^${normalizedFullname}$`, "i") }],
    });
    if (existingUser) {
      return res.status(200).json({
        success: false,
        message: {
          en: "full name is already registered. Please try a different one.",
          zh: "ÂÖ®ÂêçÂ∑≤Ë¢´Ê≥®ÂÜå„ÄÇËØ∑Â∞ùËØï‰ΩøÁî®ÂÖ∂‰ªñÂêçÁß∞„ÄÇ",
          ms: "Nama penuh sudah didaftarkan. Sila cuba nama yang lain.",
        },
      });
    }

    const existingUsername = await User.findOne({
      username: normalizedUsername,
    });
    if (existingUsername) {
      return res.status(200).json({
        success: false,
        message: {
          en: "Username is already taken. Please choose a different one.",
          zh: "Áî®Êà∑ÂêçÂ∑≤Ë¢´Âç†Áî®„ÄÇËØ∑ÈÄâÊã©ÂÖ∂‰ªñÁî®Êà∑Âêç„ÄÇ",
          ms: "Nama pengguna sudah diambil. Sila pilih yang lain.",
        },
      });
    }

    const phoneToCheck = String(phonenumber);
    const alternativePhone = phoneToCheck.startsWith("60")
      ? "0" + phoneToCheck.substring(2)
      : phoneToCheck;

    const convertToStorageFormat = (phoneNumber) => {
      if (phoneNumber && phoneNumber.startsWith("60")) {
        return "0" + phoneNumber.substring(2);
      }
      return phoneNumber;
    };
    const phoneForStorage = convertToStorageFormat(phonenumber);
    const existingPhoneNumber = await User.findOne({
      $or: [{ phonenumber: phoneToCheck }, { phonenumber: alternativePhone }],
    });

    if (existingPhoneNumber) {
      console.log("ÊâæÂà∞ÈáçÂ§çÊâãÊú∫Âè∑Á†Å:", existingPhoneNumber.phonenumber);
      return res.status(200).json({
        success: false,
        message: {
          en: "Phone number is already registered. Please use a different number.",
          zh: "ÊâãÊú∫Âè∑Á†ÅÂ∑≤Ë¢´Ê≥®ÂÜå„ÄÇËØ∑‰ΩøÁî®ÂÖ∂‰ªñÂè∑Á†Å„ÄÇ",
          ms: "Nombor telefon sudah didaftarkan. Sila gunakan nombor yang berbeza.",
        },
      });
    }
    // === IPÈáçÂ§çÊ£ÄÊµãÈÄªËæë ===
    console.log("ÂºÄÂßãÊ£ÄÊü•IPÈáçÂ§ç...");

    // Êü•ÊâæÊâÄÊúâ‰ΩøÁî®Áõ∏ÂêåIPÁöÑÁé∞ÊúâÁî®Êà∑
    const allUsersWithSameIp = await User.find({
      $or: [{ lastLoginIp: clientIp }, { registerIp: clientIp }],
    });

    console.log(`ÊâæÂà∞ ${allUsersWithSameIp.length} ‰∏™‰ΩøÁî®Áõ∏ÂêåIPÁöÑÁé∞ÊúâÁî®Êà∑:`);
    allUsersWithSameIp.forEach((foundUser, index) => {
      console.log(
        `- Áî®Êà∑${index + 1}: ${foundUser.username} (ID: ${foundUser._id})`
      );
      console.log(`  Ê≥®ÂÜåIP: ${foundUser.registerIp}`);
      console.log(`  ÊúÄÂêéÁôªÂΩïIP: ${foundUser.lastLoginIp}`);
    });

    const isDuplicateIP = allUsersWithSameIp.length > 0; // Â¶ÇÊûúÊúâÁé∞ÊúâÁî®Êà∑‰ΩøÁî®Áõ∏ÂêåIPÔºåÂàô‰∏∫ÈáçÂ§ç
    console.log("duplicateIPÊ†áËÆ∞ÁªìÊûú:", isDuplicateIP);

    if (isDuplicateIP) {
      console.log("Ê£ÄÊµãÂà∞IPÈáçÂ§çÔºåÂ∞ÜÊ†áËÆ∞ÊâÄÊúâÁõ∏ÂÖ≥Áî®Êà∑...");

      // ÂÖàÊ†áËÆ∞ÊâÄÊúâÁé∞ÊúâÁöÑÁõ∏ÂêåIPÁî®Êà∑‰∏∫duplicateIP: true
      const userIdsToUpdate = allUsersWithSameIp.map((u) => u._id);
      if (userIdsToUpdate.length > 0) {
        const bulkUpdateResult = await User.updateMany(
          { _id: { $in: userIdsToUpdate } },
          { $set: { duplicateIP: true } }
        );
        console.log(
          `ÊâπÈáèÊõ¥Êñ∞Áé∞ÊúâÁî®Êà∑ÁªìÊûú: ÂåπÈÖç ${bulkUpdateResult.matchedCount} ‰∏™Áî®Êà∑, ‰øÆÊîπ ${bulkUpdateResult.modifiedCount} ‰∏™Áî®Êà∑`
        );
      }
    }

    console.log("=== Ê≥®ÂÜåIPÊ£ÄÊµãÁªìÊùü ===");

    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);
    const newReferralCode = await generateUniqueReferralCode();
    const referralLink = generateReferralLink(newReferralCode);
    const referralQrCode = await QRCode.toDataURL(referralLink);

    let referralBy = null;
    if (referralCode) {
      const referrer = await User.findOne({ referralCode: referralCode });
      if (referrer) {
        referralBy = {
          user_id: referrer._id,
          username: referrer.username,
        };
      }
    }

    const newUser = await User.create({
      username: normalizedUsername,
      fullname: normalizedFullname,
      password: hashedPassword,
      dob,
      phonenumber: phoneForStorage,
      registerIp: clientIp,
      referralLink,
      referralCode: newReferralCode,
      referralQrCode,
      referralBy,
      duplicateIP: isDuplicateIP, // Êñ∞Áî®Êà∑‰πüÊ†áËÆ∞‰∏∫ÈáçÂ§çIPÔºàÂ¶ÇÊûúÊ£ÄÊµãÂà∞ÈáçÂ§çÔºâ
      isPhoneVerified: isPhoneVerified,
      viplevel: "Bronze",
    });

    if (referralBy) {
      await User.findByIdAndUpdate(referralBy.user_id, {
        $push: {
          referrals: {
            user_id: newUser._id,
            username: newUser.username,
          },
        },
      });
    }

    console.log(
      `Êñ∞Áî®Êà∑ÂàõÂª∫ÊàêÂäü: ${newUser.username}, duplicateIP: ${isDuplicateIP}`
    );

    try {
      await sendTelegramNotification({
        username: normalizedUsername,
        fullname: normalizedFullname,
        phonenumber: phonenumber,
        registerIp: clientIp,
        duplicateIP: isDuplicateIP,
        referralBy: referralBy?.username,
      });
    } catch (error) {
      console.error("Telegram notification error:", error);
    }

    res.status(200).json({
      success: true,
      message: {
        en: "User created successfully",
        zh: "Áî®Êà∑ÂàõÂª∫ÊàêÂäü",
        ms: "Pengguna berjaya dicipta",
      },
    });
  } catch (error) {
    console.error("Error occurred while creating user:", error);
    res.status(200).json({
      success: false,
      message: {
        en: "Registration failed due to a system error. Please try again later",
        zh: "Áî±‰∫éÁ≥ªÁªüÈîôËØØÔºåÊ≥®ÂÜåÂ§±Ë¥•„ÄÇËØ∑Á®çÂêéÂÜçËØï",
        ms: "Pendaftaran gagal kerana ralat sistem. Sila cuba lagi kemudian",
      },
    });
  }
});

// Refresh Token

// User Login
// router.post("/api/login", loginLimiter, async (req, res) => {
//   const { username, password } = req.body;
//   const normalizedUsername = username.toLowerCase();
//   let clientIp = req.headers["x-forwarded-for"] || req.ip;
//   clientIp = clientIp.split(",")[0].trim();
//   const geo = geoip.lookup(clientIp);
//   try {
//     const user = await User.findOne({
//       username: normalizedUsername,
//     });
//     if (!user) {
//       await userLogAttempt(
//         normalizedUsername,
//         "-",
//         null,
//         req.get("User-Agent"),
//         clientIp,
//         geo ? geo.country : "Unknown",
//         geo ? geo.city : "Unknown",
//         `Invalid Login: Wrong Username Attempted ${normalizedUsername}`
//       );
//       return res.status(200).json({
//         success: false,
//         message: {
//           en: "Login unsuccessful. Please ensure your details are correct or contact customer service.",
//           zh: "ÁôªÂΩïÂ§±Ë¥•„ÄÇËØ∑Á°ÆËÆ§ÊÇ®ÁöÑ‰ø°ÊÅØÊ≠£Á°ÆÊàñËÅîÁ≥ªÂÆ¢Êúç„ÄÇ",
//           ms: "Log masuk tidak berjaya. Sila pastikan butiran anda betul atau hubungi khidmat pelanggan.",
//         },
//       });
//     }
//     const isPasswordCorrect = await bcrypt.compare(password, user.password);
//     if (!isPasswordCorrect) {
//       await userLogAttempt(
//         user.username,
//         user.fullname,
//         user.phonenumber,
//         req.get("User-Agent"),
//         clientIp,
//         geo ? geo.country : "Unknown",
//         geo ? geo.city : "Unknown",
//         `Invalid Login: Wrong Password Attempted ${password}`
//       );
//       return res.status(200).json({
//         success: false,
//         message: {
//           en: "Login unsuccessful. Please ensure your details are correct or contact customer service.",
//           zh: "ÁôªÂΩïÂ§±Ë¥•„ÄÇËØ∑Á°ÆËÆ§ÊÇ®ÁöÑ‰ø°ÊÅØÊ≠£Á°ÆÊàñËÅîÁ≥ªÂÆ¢Êúç„ÄÇ",
//           ms: "Log masuk tidak berjaya. Sila pastikan butiran anda betul atau hubungi khidmat pelanggan.",
//         },
//       });
//     }
//     if (user.status === false) {
//       await userLogAttempt(
//         user.username,
//         user.fullname,
//         user.phonenumber,
//         req.get("User-Agent"),
//         clientIp,
//         geo ? geo.country : "Unknown",
//         geo ? geo.city : "Unknown",
//         "Invalid Login: Account Is Inactive"
//       );
//       return res.status(200).json({
//         success: false,
//         status: "inactive",
//         message: {
//           en: "Your account is currently inactive",
//           zh: "ÊÇ®ÁöÑË¥¶Âè∑ÂΩìÂâçÊú™ÊøÄÊ¥ª",
//           ms: "Akaun anda kini tidak aktif",
//         },
//       });
//     }
//     await User.findByIdAndUpdate(user._id, {
//       lastLogin: new Date(),
//       lastLoginIp: clientIp,
//     });

//     const { token, refreshToken, newGameToken } = await handleLoginSuccess(
//       user._id
//     );

//     await userLogAttempt(
//       user.username,
//       user.fullname,
//       user.phonenumber,
//       req.get("User-Agent"),
//       clientIp,
//       geo ? geo.country : "Unknown",
//       geo ? geo.city : "Unknown",
//       "Login Success"
//     );
//     res.status(200).json({
//       success: true,
//       token,
//       refreshToken,
//       newGameToken,
//       message: {
//         en: "Login successful",
//         zh: "ÁôªÂΩïÊàêÂäü",
//         ms: "Log masuk berjaya",
//       },
//     });
//   } catch (error) {
//     res.status(500).json({
//       success: false,
//       message: {
//         en: "An error occurred. Please try again later",
//         zh: "ÂèëÁîüÈîôËØØÔºåËØ∑Á®çÂêéÂÜçËØï",
//         ms: "Ralat berlaku. Sila cuba lagi kemudian",
//       },
//     });
//   }
// });

// User Login
router.post("/api/login", loginLimiter, async (req, res) => {
  let { username, password } = req.body;
  username = username?.trim().replace(/\s+/g, " ") || "";
  const normalizedUsername = username.toLowerCase();
  let clientIp = req.headers["x-forwarded-for"] || req.ip;
  clientIp = clientIp.split(",")[0].trim();
  const geo = geoip.lookup(clientIp);

  console.log("=== ÁôªÂΩïIPÊ£ÄÊµãË∞ÉËØï ===");
  console.log("ÂΩìÂâçÁôªÂΩïÁî®Êà∑Âêç:", normalizedUsername);
  console.log("ÂΩìÂâçÁî®Êà∑IP:", clientIp);

  try {
    const user = await User.findOne({
      username: normalizedUsername,
    });

    if (!user) {
      await userLogAttempt(
        normalizedUsername,
        "-",
        null,
        req.get("User-Agent"),
        clientIp,
        geo ? geo.country : "Unknown",
        geo ? geo.city : "Unknown",
        `Invalid Login: Wrong Username Attempted ${normalizedUsername}`
      );
      return res.status(200).json({
        success: false,
        message: {
          en: "Login unsuccessful. Please ensure your details are correct or contact customer service.",
          zh: "ÁôªÂΩïÂ§±Ë¥•„ÄÇËØ∑Á°ÆËÆ§ÊÇ®ÁöÑ‰ø°ÊÅØÊ≠£Á°ÆÊàñËÅîÁ≥ªÂÆ¢Êúç„ÄÇ",
          ms: "Log masuk tidak berjaya. Sila pastikan butiran anda betul atau hubungi khidmat pelanggan.",
        },
      });
    }

    const isPasswordCorrect = await bcrypt.compare(password, user.password);
    if (!isPasswordCorrect) {
      await userLogAttempt(
        user.username,
        user.fullname,
        user.phonenumber,
        req.get("User-Agent"),
        clientIp,
        geo ? geo.country : "Unknown",
        geo ? geo.city : "Unknown",
        `Invalid Login: Wrong Password Attempted ${password}`
      );
      return res.status(200).json({
        success: false,
        message: {
          en: "Login unsuccessful. Please ensure your details are correct or contact customer service.",
          zh: "ÁôªÂΩïÂ§±Ë¥•„ÄÇËØ∑Á°ÆËÆ§ÊÇ®ÁöÑ‰ø°ÊÅØÊ≠£Á°ÆÊàñËÅîÁ≥ªÂÆ¢Êúç„ÄÇ",
          ms: "Log masuk tidak berjaya. Sila pastikan butiran anda betul atau hubungi khidmat pelanggan.",
        },
      });
    }

    if (user.status === false) {
      await userLogAttempt(
        user.username,
        user.fullname,
        user.phonenumber,
        req.get("User-Agent"),
        clientIp,
        geo ? geo.country : "Unknown",
        geo ? geo.city : "Unknown",
        "Invalid Login: Account Is Inactive"
      );
      return res.status(200).json({
        success: false,
        status: "inactive",
        message: {
          en: "Your account is currently inactive",
          zh: "ÊÇ®ÁöÑË¥¶Âè∑ÂΩìÂâçÊú™ÊøÄÊ¥ª",
          ms: "Akaun anda kini tidak aktif",
        },
      });
    }

    // === IPÈáçÂ§çÊ£ÄÊµãÈÄªËæë ===
    console.log("ÂºÄÂßãÊ£ÄÊü•IPÈáçÂ§ç...");

    // Êü•ÊâæÊâÄÊúâ‰ΩøÁî®Áõ∏ÂêåIPÁöÑÁî®Êà∑ÔºàÂåÖÊã¨ÂΩìÂâçÁî®Êà∑Ôºâ
    const allUsersWithSameIp = await User.find({
      _id: { $ne: user._id },
      $or: [{ lastLoginIp: clientIp }, { registerIp: clientIp }],
    });

    console.log(`ÊâæÂà∞ ${allUsersWithSameIp.length} ‰∏™‰ΩøÁî®Áõ∏ÂêåIPÁöÑÁî®Êà∑:`);
    allUsersWithSameIp.forEach((foundUser, index) => {
      console.log(
        `- Áî®Êà∑${index + 1}: ${foundUser.username} (ID: ${foundUser._id})`
      );
      console.log(`  Ê≥®ÂÜåIP: ${foundUser.registerIp}`);
      console.log(`  ÊúÄÂêéÁôªÂΩïIP: ${foundUser.lastLoginIp}`);
    });

    const isDuplicateIP = allUsersWithSameIp.length > 0;
    console.log("duplicateIPÊ†áËÆ∞ÁªìÊûú:", isDuplicateIP);

    if (isDuplicateIP) {
      console.log("Ê£ÄÊµãÂà∞IPÈáçÂ§çÔºåÂºÄÂßãÊõ¥Êñ∞ÊâÄÊúâÁõ∏ÂÖ≥Áî®Êà∑...");

      // ÊâπÈáèÊõ¥Êñ∞ÊâÄÊúâ‰ΩøÁî®Áõ∏ÂêåIPÁöÑÁî®Êà∑ÔºåÂ∞Ü‰ªñ‰ª¨ÈÉΩÊ†áËÆ∞‰∏∫duplicateIP: true
      const userIdsToUpdate = [
        ...allUsersWithSameIp.map((u) => u._id),
        user._id,
      ];
      const bulkUpdateResult = await User.updateMany(
        { _id: { $in: userIdsToUpdate } },
        { $set: { duplicateIP: true } }
      );

      console.log(
        `ÊâπÈáèÊõ¥Êñ∞ÁªìÊûú: ÂåπÈÖç ${bulkUpdateResult.matchedCount} ‰∏™Áî®Êà∑, ‰øÆÊîπ ${bulkUpdateResult.modifiedCount} ‰∏™Áî®Êà∑`
      );
    }

    console.log("=== ÁôªÂΩïIPÊ£ÄÊµãÁªìÊùü ===");

    // Êõ¥Êñ∞ÂΩìÂâçÁôªÂΩïÁî®Êà∑ÁöÑÁôªÂΩï‰ø°ÊÅØ
    await User.findByIdAndUpdate(user._id, {
      lastLogin: new Date(),
      lastLoginIp: clientIp,
      // duplicateIP Â∑≤ÁªèÂú®‰∏äÈù¢ÁöÑÊâπÈáèÊõ¥Êñ∞‰∏≠Â§ÑÁêÜ‰∫Ü
    });

    const { token, refreshToken, newGameToken } = await handleLoginSuccess(
      user._id
    );

    await userLogAttempt(
      user.username,
      user.fullname,
      user.phonenumber,
      req.get("User-Agent"),
      clientIp,
      geo ? geo.country : "Unknown",
      geo ? geo.city : "Unknown",
      isDuplicateIP ? "Login Success - Duplicate IP Detected" : "Login Success"
    );

    res.status(200).json({
      success: true,
      token,
      refreshToken,
      newGameToken,
      message: {
        en: "Login successful",
        zh: "ÁôªÂΩïÊàêÂäü",
        ms: "Log masuk berjaya",
      },
    });
  } catch (error) {
    console.error("Login error:", error);
    res.status(500).json({
      success: false,
      message: {
        en: "An error occurred. Please try again later",
        zh: "ÂèëÁîüÈîôËØØÔºåËØ∑Á®çÂêéÂÜçËØï",
        ms: "Ralat berlaku. Sila cuba lagi kemudian",
      },
    });
  }
});

// Refresh Token
router.post("/api/refresh-token", async (req, res) => {
  const authHeader = req.headers["authorization"];
  const refreshToken = authHeader && authHeader.split(" ")[1];
  if (!refreshToken) {
    return res.status(401).json({ message: "Refresh token not provided" });
  }
  try {
    const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);
    const newToken = await generateToken(decoded.userId);

    res.json({
      success: true,
      token: newToken,
    });
  } catch (error) {
    res.status(401).json({ message: "Invalid refresh token" });
  }
});

router.post("/api/game-token", authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const user = await User.findById(userId);

    const newGameToken = await generateGameToken(user._id);

    return res.status(200).json({
      success: true,
      gameToken: newGameToken,
    });
  } catch (error) {
    res.status(401).json({ message: "Invalid game token" });
  }
});

router.post(
  "/api/game-token-validtest",
  authenticateToken,
  async (req, res) => {
    const userId = req.user.userId;
    const user = await User.findById(userId);

    try {
      const { gameToken } = req.body;

      const decodedToken = jwt.verify(gameToken, process.env.JWT_GAME_SECRET);

      return res.status(200).json({
        success: true,
      });
    } catch (error) {
      if (
        error.message === "jwt expired" ||
        error.message === "invalid token" ||
        error.message === "jwt malformed"
      ) {
        const newGameToken = await generateGameToken(user._id);

        return res.status(200).json({
          success: false,
          gameToken: newGameToken,
        });
      } else {
        res.status(401).json({ message: "Invalid game token" });
      }
    }
  }
);

// Logout User
router.post("/api/logout", authenticateToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    let clientIp = req.headers["x-forwarded-for"] || req.ip;
    clientIp = clientIp.split(",")[0].trim();
    const geo = geoip.lookup(clientIp);
    await userLogAttempt(
      user.username,
      user.fullname,
      user.phonenumber,
      req.get("User-Agent"),
      clientIp,
      geo ? geo.country : "Unknown",
      geo ? geo.city : "Unknown",
      "Logout Success"
    );
    res.status(200).json({
      success: true,
      message: {
        en: "Logout successful",
        zh: "ÁôªÂá∫ÊàêÂäü",
        ms: "Log keluar berjaya",
      },
    });
  } catch (error) {
    console.error("Error occurred while logging out:", error);
    res.status(500).json({
      success: false,
      message: {
        en: "An error occurred while logging out",
        zh: "ÁôªÂá∫Êó∂ÂèëÁîüÈîôËØØ",
        ms: "Ralat berlaku semasa log keluar",
      },
    });
  }
});

// Get User Data
router.get("/api/userdata", authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const user = await User.findById(userId).select(
      "fullname username bankAccounts totaldeposit email lastRebateClaim lastCommissionClaim telegramId facebookId lastLogin phonenumber luckySpinClaim  wallet createdAt dob withdrawlock rebate email isPhoneVerified isEmailVerified monthlyBonusCountdownTime monthlyLoyaltyCountdownTime weeklySignInTime totaldeposit viplevel cryptoWallet luckySpinCount luckySpinAmount referralLink referralCode referralQrCode positionTaking totalturnover firstDepositDate gw99GameID gw99GamePW alipayGameID lionKingGameID "
    );
    if (!user) {
      return res.status(200).json({ message: "Áî®Êà∑Êú™ÊâæÂà∞" });
    }
    res.status(200).json({ success: true, user });
  } catch (error) {
    console.error("Error occurred while retrieving user data:", error);
    res.status(200).json({ message: "Internal server error" });
  }
});

// Change User Password
router.post("/api/changepassword", authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { oldPassword, newPassword, confirmPassword } = req.body;
    if (!oldPassword || !newPassword || !confirmPassword) {
      return res.status(200).json({
        success: false,
        message: {
          en: "Please enter both old password and new password",
          zh: "ËØ∑ËæìÂÖ•ÊóßÂØÜÁ†ÅÂíåÊñ∞ÂØÜÁ†Å",
          ms: "Sila masukkan kata laluan lama dan kata laluan baru",
        },
      });
    }
    if (newPassword !== confirmPassword) {
      return res.status(200).json({
        success: false,
        message: {
          en: "New passwords do not match",
          zh: "ËæìÂÖ•ÁöÑÊñ∞ÂØÜÁ†Å‰∏çÂåπÈÖç",
          ms: "Kata laluan baru tidak sepadan",
        },
      });
    }
    if (newPassword.length < 8) {
      return res.status(200).json({
        success: false,
        message: {
          en: "Password must be at least 8 characters long",
          zh: "ÂØÜÁ†ÅÈïøÂ∫¶ÂøÖÈ°ªËá≥Â∞ë‰∏∫8‰∏™Â≠óÁ¨¶",
          ms: "Kata laluan mestilah sekurang-kurangnya 8 aksara",
        },
      });
    }
    const user = await User.findById(userId);
    const isMatch = await bcrypt.compare(oldPassword, user.password);
    if (!isMatch) {
      return res.status(200).json({
        success: false,
        message: {
          en: "Current password is incorrect",
          zh: "ÂΩìÂâçÂØÜÁ†Å‰∏çÊ≠£Á°Æ",
          ms: "Kata laluan semasa tidak betul",
        },
      });
    }
    if (oldPassword === newPassword) {
      return res.status(200).json({
        success: false,
        message: {
          en: "New password cannot be the same as the current password",
          zh: "Êñ∞ÂØÜÁ†Å‰∏çËÉΩ‰∏éÂΩìÂâçÂØÜÁ†ÅÁõ∏Âêå",
          ms: "Kata laluan baru tidak boleh sama dengan kata laluan semasa",
        },
      });
    }
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(newPassword, salt);
    user.password = hashedPassword;
    await user.save();
    res.status(200).json({
      success: true,
      message: {
        en: "Password has been changed successfully",
        zh: "ÂØÜÁ†Å‰øÆÊîπÊàêÂäü",
        ms: "Kata laluan telah berjaya ditukar",
      },
    });
  } catch (error) {
    console.error("Change password error:", error);
    res.status(500).json({
      success: false,
      message: {
        en: "An error occurred. Please try again later",
        zh: "ÂèëÁîüÈîôËØØÔºåËØ∑Á®çÂêéÂÜçËØï",
        ms: "Ralat berlaku. Sila cuba lagi kemudian",
      },
    });
  }
});

// Add Bank
router.post("/api/addbank", async (req, res) => {
  try {
    const { name, bankname, banknumber } = req.body;
    if (!bankname || !banknumber || !name) {
      return res.status(200).json({
        success: false,
        message: {
          en: "Bank name, account number and name cannot be empty",
          zh: "Èì∂Ë°åÂêçÁß∞„ÄÅË¥¶Âè∑ÂíåÂßìÂêç‰∏çËÉΩ‰∏∫Á©∫",
          ms: "Nama bank, nombor akaun dan nama tidak boleh kosong",
        },
      });
    }

    const normalizedName = name.toLowerCase();

    const [userCheck, duplicateCheck] = await Promise.all([
      User.findOne({ fullname: normalizedName }).select("bankAccounts"),
      User.findOne({ "bankAccounts.banknumber": banknumber }).select("_id"),
    ]);

    if (duplicateCheck) {
      return res.status(200).json({
        success: false,
        message: {
          en: "This bank account number is already registered",
          zh: "Ê≠§Èì∂Ë°åË¥¶Âè∑Â∑≤Ë¢´Ê≥®ÂÜå",
          ms: "Nombor akaun bank ini telah didaftarkan",
        },
      });
    }

    if (!userCheck) {
      return res.status(200).json({
        success: false,
        message: {
          en: "User not found",
          zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          ms: "Pengguna tidak dijumpai",
        },
      });
    }

    if (userCheck.bankAccounts.length >= 1) {
      return res.status(200).json({
        success: false,
        message: {
          en: "Maximum 1 bank accounts allowed",
          zh: "ÊúÄÂ§öÂè™ËÉΩÊ∑ªÂä†1‰∏™Èì∂Ë°åË¥¶Êà∑",
          ms: "Maksimum 1 akaun bank dibenarkan",
        },
      });
    }

    await User.updateOne(
      { fullname: normalizedName },
      { $push: { bankAccounts: { name, bankname, banknumber } } }
    );

    res.json({
      success: true,
      message: {
        en: "Bank account added successfully",
        zh: "Èì∂Ë°åË¥¶Êà∑Ê∑ªÂä†ÊàêÂäü",
        ms: "Akaun bank berjaya ditambah",
      },
    });
  } catch (error) {
    console.error("Error in addbank API:", error);
    res.status(500).json({
      success: false,
      message: {
        en: "Internal server error",
        zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
        ms: "Ralat dalaman pelayan",
      },
    });
  }
});

// Admin Get Same User Bank Number
router.get(
  "/admin/api/users/find-by-bank/:banknumber",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const { banknumber } = req.params;
      const trimmedBanknumber = banknumber.trim();
      const users = await User.find(
        {
          "bankAccounts.banknumber": { $exists: true },
        },
        {
          username: 1,
          fullname: 1,
          bankAccounts: 1,
          _id: 0,
        }
      );
      const matchedUsers = users.filter((user) =>
        user.bankAccounts.some(
          (account) =>
            account.banknumber &&
            account.banknumber.toString().trim() === trimmedBanknumber
        )
      );
      if (!matchedUsers || matchedUsers.length === 0) {
        return res.status(200).json({
          success: true,
          data: [],
          message: "No users found with this bank number",
        });
      }
      const formattedUsers = matchedUsers.map((user) => {
        const matchingBankAccounts = user.bankAccounts.filter(
          (account) =>
            account.banknumber &&
            account.banknumber.toString().trim() === trimmedBanknumber
        );
        return {
          username: user.username,
          fullname: user.fullname,
          bankAccounts: matchingBankAccounts,
        };
      });
      return res.status(200).json({
        success: true,
        data: formattedUsers,
        message: `Found ${matchedUsers.length} user(s) with bank number: ${trimmedBanknumber}`,
      });
    } catch (error) {
      console.error("Error finding users by bank number:", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error",
      });
    }
  }
);

// Get User Bank
router.get("/api/getbank", authenticateToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId).select("bankAccounts");
    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }
    res.json({
      success: true,
      data: user.bankAccounts,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
});

// Delete User Bank
router.delete("/api/userbank", authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { bankAccountId } = req.body;
    const result = await User.updateOne(
      { _id: userId },
      { $pull: { bankAccounts: { _id: bankAccountId } } }
    );
    if (result.matchedCount === 0) {
      return res.status(200).json({
        success: false,
        message: {
          en: "User not found",
          zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
        },
      });
    }
    res.status(200).json({
      success: true,
      message: {
        en: "Bank account deleted successfully",
        zh: "Èì∂Ë°åË¥¶Êà∑Â∑≤ÊàêÂäüÂà†Èô§",
      },
    });
  } catch (error) {
    console.error("Error deleting bank account:", error);
    res.status(500).json({
      success: false,
      message: {
        en: "Failed to delete bank account",
        zh: "Âà†Èô§Èì∂Ë°åË¥¶Êà∑Â§±Ë¥•",
      },
    });
  }
});

async function checkAndUpdateVIPLevel(userId) {
  try {
    const user = await User.findById(userId);
    if (!user) {
      console.error("User not found when checking VIP level");
      return { success: false, message: "User not found" };
    }
    const vipSettings = await vip.findOne({});
    if (
      !vipSettings ||
      !vipSettings.vipLevels ||
      vipSettings.vipLevels.length === 0
    ) {
      console.error("VIP settings not found");
      return { success: false, message: "VIP settings not found" };
    }
    const totalDeposit = user.totaldeposit;
    const sortedVipLevels = [...vipSettings.vipLevels].sort((a, b) => {
      let depositA = 0;
      let depositB = 0;
      if (a.benefits instanceof Map) {
        depositA = parseFloat(a.benefits.get("Total Deposit") || 0);
      } else {
        depositA = parseFloat(a.benefits["Total Deposit"] || 0);
      }

      if (b.benefits instanceof Map) {
        depositB = parseFloat(b.benefits.get("Total Deposit") || 0);
      } else {
        depositB = parseFloat(b.benefits["Total Deposit"] || 0);
      }

      return depositB - depositA;
    });
    let newLevel = null;
    for (const level of sortedVipLevels) {
      let requiredDeposit = 0;
      if (level.benefits instanceof Map) {
        requiredDeposit = parseFloat(level.benefits.get("Total Deposit") || 0);
      } else {
        requiredDeposit = parseFloat(level.benefits["Total Deposit"] || 0);
      }
      if (totalDeposit >= requiredDeposit) {
        newLevel = level.name;
        break;
      }
    }
    if (!newLevel && sortedVipLevels.length > 0) {
      const lowestLevelIndex = sortedVipLevels.length - 1;
      newLevel = sortedVipLevels[lowestLevelIndex].name;
    }
    if (newLevel && newLevel !== user.viplevel) {
      const oldLevel = user.viplevel;
      user.viplevel = newLevel;
      await user.save();
      console.log(
        `User ${user.username} VIP level updated from ${oldLevel} to ${newLevel}`
      );
      try {
        // ÂÅáËÆæÊÇ®Êúâ‰∏Ä‰∏™VIPChangeLogÊ®°ÂûãÊù•ËÆ∞ÂΩïVIPÂèòÊõ¥
        /*
        await new VIPChangeLog({
          userId: user._id,
          username: user.username,
          oldLevel,
          newLevel,
          reason: "Total deposit threshold reached",
          totalDeposit: user.totaldeposit
        }).save();
        */
      } catch (logError) {
        console.error("Error logging VIP change:", logError);
      }
      return {
        success: true,
        message: "VIP level updated",
        oldLevel,
        newLevel,
      };
    }

    return {
      success: true,
      message: "VIP level checked, no update needed",
      currentLevel: user.viplevel,
    };
  } catch (error) {
    console.error("Error in checkAndUpdateVIPLevel:", error);
    return {
      success: false,
      message: "Internal server error",
      error: error.message,
    };
  }
}

// Admin Approve Deposit
router.post(
  "/admin/api/approvedeposit/:depositId",
  authenticateAdminToken,
  async (req, res) => {
    const { depositId } = req.params;
    const { depositname } = req.body;
    const userId = req.user.userId;
    const adminuser = await adminUser.findById(userId);
    if (!adminuser) {
      return res.status(200).json({
        success: false,
        message: {
          en: "Admin User not found, please contact customer service",
          zh: "Êú™ÊâæÂà∞ÁÆ°ÁêÜÂëòÁî®Êà∑ÔºåËØ∑ËÅîÁ≥ªÂÆ¢Êà∑ÊúçÂä°",
        },
      });
    }
    try {
      const deposit = await Deposit.findById(depositId);
      if (!deposit) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Deposit record not found",
            zh: "Êâæ‰∏çÂà∞Â≠òÊ¨æËÆ∞ÂΩï",
          },
        });
      }
      if (deposit.status !== "pending") {
        return res.status(200).json({
          success: false,
          message: {
            en: "Deposit has been processed or status is incorrect",
            zh: "Â≠òÊ¨æÂ∑≤Â§ÑÁêÜÊàñÁä∂ÊÄÅ‰∏çÊ≠£Á°Æ",
          },
        });
      }
      const user = await User.findOne({ username: deposit.username });
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }
      const bank = await BankList.findById(deposit.bankid);
      if (!bank) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Bank not found",
            zh: "Êâæ‰∏çÂà∞Èì∂Ë°å",
          },
        });
      }

      const kioskSettings = await kioskbalance.findOne({});
      if (kioskSettings && kioskSettings.status) {
        const kioskResult = await updateKioskBalance(
          "subtract",
          deposit.amount,
          {
            username: user.username,
            transactionType: "deposit approval",
            remark: `Deposit ID: ${deposit._id}`,
            processBy: adminuser.username,
          }
        );
        if (!kioskResult.success) {
          return res.status(200).json({
            success: false,
            message: {
              en: "Failed to update kiosk balance",
              zh: "Êõ¥Êñ∞Kiosk‰ΩôÈ¢ùÂ§±Ë¥•",
            },
          });
        }
      }

      const formattedProcessTime = calculateProcessingTime(deposit.createdAt);
      if (user.firstDepositDate === null) {
        deposit.newDeposit = true;
      }

      deposit.status = "approved";
      deposit.processBy = adminuser.username;
      deposit.processtime = formattedProcessTime;
      if (depositname) {
        deposit.depositname = depositname;
      }
      await deposit.save();

      const spinSetting = await LuckySpinSetting.findOne();
      let spinCount = 0;
      if (spinSetting) {
        spinCount = Math.floor(deposit.amount / spinSetting.depositAmount);
      }

      const updateFields = {
        $inc: {
          totaldeposit: deposit.amount,
          wallet: deposit.amount,
          ...(spinCount > 0 && { luckySpinCount: spinCount }),
        },
        $set: {
          lastdepositdate: new Date(),
          ...(user.firstDepositDate === null && {
            firstDepositDate: deposit.createdAt,
          }),
        },
      };

      await User.findByIdAndUpdate(user._id, updateFields);

      await checkAndUpdateVIPLevel(user._id);

      const walletLog = await UserWalletLog.findOne({
        transactionid: deposit.transactionId,
        status: "pending",
      });

      if (walletLog) {
        walletLog.status = "approved";
        await walletLog.save();
      } else {
        console.error("UserWalletLog record not found for the deposit.");
      }

      // bank.totalDeposits += deposit.amount;
      // bank.currentbalance =
      //   bank.startingbalance +
      //   bank.totalDeposits -
      //   bank.totalWithdrawals +
      //   bank.totalCashIn -
      //   bank.totalCashOut;
      // await bank.save();

      const updatedBank = await BankList.findByIdAndUpdate(
        deposit.bankid,
        [
          {
            $set: {
              totalDeposits: { $add: ["$totalDeposits", deposit.amount] },
              currentbalance: {
                $subtract: [
                  {
                    $add: [
                      "$startingbalance",
                      { $add: ["$totalDeposits", deposit.amount] },
                      "$totalCashIn",
                    ],
                  },
                  {
                    $add: ["$totalWithdrawals", "$totalCashOut"],
                  },
                ],
              },
            },
          },
        ],
        { new: true }
      );

      const depositLog = new BankTransactionLog({
        bankName: bank.bankname,
        ownername: bank.ownername,
        remark: deposit.remark,
        lastBalance: updatedBank.currentbalance - deposit.amount,
        currentBalance: updatedBank.currentbalance,
        processby: adminuser.username,
        qrimage: bank.qrimage,
        playerusername: user.username,
        playerfullname: user.fullname,
        transactiontype: deposit.transactionType,
        amount: deposit.amount,
      });

      await depositLog.save();

      await updateAverageProcessingTime(
        adminuser.username,
        deposit.processtime,
        "deposit"
      );

      res.status(200).json({
        success: true,
        message: {
          en: "Deposit approved successfully, wallet balance updated",
          zh: "Â≠òÊ¨æÂ∑≤ÊàêÂäüÊâπÂáÜÔºåÈí±ÂåÖ‰ΩôÈ¢ùÂ∑≤Êõ¥Êñ∞",
        },
      });
    } catch (error) {
      console.error("Error occurred while approving deposit:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Internal server error",
          zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
        },
      });
    }
  }
);

// Admin Approve Withdraw
router.post(
  "/admin/api/approvewithdraw/:withdrawId",
  authenticateAdminToken,
  async (req, res) => {
    const { withdrawId } = req.params;
    const { bankId, cashoutAmount } = req.body;
    const userId = req.user.userId;
    const adminuser = await adminUser.findById(userId);
    if (!adminuser) {
      return res.status(200).json({
        success: false,
        message: {
          en: "Admin User not found, please contact customer service",
          zh: "Êú™ÊâæÂà∞ÁÆ°ÁêÜÂëòÁî®Êà∑ÔºåËØ∑ËÅîÁ≥ªÂÆ¢Êà∑ÊúçÂä°",
        },
      });
    }
    try {
      const withdraw = await Withdraw.findById(withdrawId);
      if (!withdraw) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Withdraw record not found",
            zh: "Êâæ‰∏çÂà∞ÊèêÊ¨æËÆ∞ÂΩï",
          },
        });
      }
      if (withdraw.status !== "pending") {
        return res.status(200).json({
          success: false,
          message: {
            en: "Withdraw has been processed or status is incorrect",
            zh: "ÊèêÊ¨æÂ∑≤Â§ÑÁêÜÊàñÁä∂ÊÄÅ‰∏çÊ≠£Á°Æ",
          },
        });
      }
      const bank = await BankList.findById(bankId);
      if (!bank) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Bank not found",
            zh: "Êâæ‰∏çÂà∞Èì∂Ë°å",
          },
        });
      }
      const actualWithdrawAmount =
        cashoutAmount && cashoutAmount > 0
          ? withdraw.amount - cashoutAmount
          : withdraw.amount;
      if (actualWithdrawAmount <= 0) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Invalid withdraw amount after cashout adjustment",
            zh: "Ë∞ÉÊï¥ÂêéÁöÑÊèêÊ¨æÈáëÈ¢ùÊó†Êïà",
          },
        });
      }
      if (bank.currentbalance < actualWithdrawAmount) {
        return res.status(200).json({
          success: false,
          message: {
            en: "The bank's current balance is insufficient to cover this withdrawal",
            zh: "Èì∂Ë°åÂΩìÂâç‰ΩôÈ¢ù‰∏çË∂≥‰ª•ÊîØ‰ªòÊ≠§ÊèêÊ¨æ",
          },
        });
      }
      const user = await User.findOne({ username: withdraw.username });
      const formattedProcessTime = calculateProcessingTime(withdraw.createdAt);
      const kioskSettings = await kioskbalance.findOne({});
      if (kioskSettings && kioskSettings.status) {
        const kioskResult = await updateKioskBalance(
          "add",
          actualWithdrawAmount,
          {
            username: user.username,
            transactionType: "withdraw approval",
            remark: `Withdraw ID: ${withdraw._id}`,
            processBy: adminuser.username,
          }
        );
        if (!kioskResult.success) {
          return res.status(200).json({
            success: false,
            message: {
              en: "Failed to update kiosk balance",
              zh: "Êõ¥Êñ∞Kiosk‰ΩôÈ¢ùÂ§±Ë¥•",
            },
          });
        }
      }
      // bank.totalWithdrawals += actualWithdrawAmount;
      // bank.currentbalance =
      //   bank.startingbalance +
      //   bank.totalDeposits -
      //   bank.totalWithdrawals +
      //   bank.totalCashIn -
      //   bank.totalCashOut;
      // await bank.save();
      const updatedBank = await BankList.findByIdAndUpdate(
        bankId,
        [
          {
            $set: {
              totalWithdrawals: {
                $add: ["$totalWithdrawals", actualWithdrawAmount],
              },
              currentbalance: {
                $subtract: [
                  {
                    $add: [
                      "$startingbalance",
                      "$totalDeposits",
                      "$totalCashIn",
                    ],
                  },
                  {
                    $add: [
                      { $add: ["$totalWithdrawals", actualWithdrawAmount] },
                      "$totalCashOut",
                    ],
                  },
                ],
              },
            },
          },
        ],
        { new: true }
      );
      if (cashoutAmount && cashoutAmount > 0) {
        withdraw.remark = `Original Amount: ${withdraw.amount}\nCashout: ${cashoutAmount}\nActual Withdraw: ${actualWithdrawAmount}`;
      }
      withdraw.amount = actualWithdrawAmount;
      withdraw.status = "approved";
      withdraw.processBy = adminuser.username;
      withdraw.processtime = formattedProcessTime;
      withdraw.withdrawbankid = bankId;
      await withdraw.save();
      const walletLog = await UserWalletLog.findOne({
        transactionid: withdraw.transactionId,
        status: "pending",
      });

      if (walletLog) {
        walletLog.status = "approved";
        walletLog.amount = actualWithdrawAmount;
        await walletLog.save();
      } else {
        console.error("UserWalletLog record not found for the Withdraw.");
      }
      await User.findByIdAndUpdate(user._id, {
        $inc: { totalwithdraw: actualWithdrawAmount },
      });
      const withdrawLog = new BankTransactionLog({
        bankName: bank.bankname,
        ownername: bank.ownername,
        remark: withdraw.remark,
        lastBalance: updatedBank.currentbalance + actualWithdrawAmount,
        currentBalance: updatedBank.currentbalance,
        processby: adminuser.username,
        qrimage: bank.qrimage,
        playerusername: user.username,
        playerfullname: user.fullname,
        transactiontype: withdraw.transactionType,
        amount: actualWithdrawAmount,
      });
      await withdrawLog.save();

      await updateAverageProcessingTime(
        adminuser.username,
        withdraw.processtime,
        "withdrawal"
      );
      res.status(200).json({
        success: true,
        message: {
          en: "Withdrawal approved successfully",
          zh: "ÊèêÊ¨æÂ∑≤ÊàêÂäüÊâπÂáÜ",
        },
      });
    } catch (error) {
      console.error("Error occurred while approving withdrawal:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Internal server error",
          zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
        },
      });
    }
  }
);

// Admin Approve Bonus
router.post(
  "/admin/api/approvebonus/:bonusId",
  authenticateAdminToken,
  async (req, res) => {
    const { bonusId } = req.params;
    const userId = req.user.userId;
    const adminuser = await adminUser.findById(userId);
    if (!adminuser) {
      return res.status(200).json({
        success: false,
        message: {
          en: "Admin User not found, please contact customer service",
          zh: "Êú™ÊâæÂà∞ÁÆ°ÁêÜÂëòÁî®Êà∑ÔºåËØ∑ËÅîÁ≥ªÂÆ¢Êà∑ÊúçÂä°",
        },
      });
    }

    try {
      const bonus = await Bonus.findById(bonusId);
      if (!bonus) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Bonus record not found",
            zh: "Êâæ‰∏çÂà∞Â•ñÈáëËÆ∞ÂΩï",
          },
        });
      }
      if (bonus.status !== "pending") {
        return res.status(200).json({
          success: false,
          message: {
            en: "Bonus has been processed or status is incorrect",
            zh: "Â•ñÈáëÂ∑≤Â§ÑÁêÜÊàñÁä∂ÊÄÅ‰∏çÊ≠£Á°Æ",
          },
        });
      }
      const user = await User.findOne({ username: bonus.username });
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }

      const kioskSettings = await kioskbalance.findOne({});
      if (kioskSettings && kioskSettings.status) {
        const kioskResult = await updateKioskBalance("subtract", bonus.amount, {
          username: user.username,
          transactionType: "bonus approval",
          remark: `Bonus ID: ${bonus._id}`,
          processBy: adminuser.username,
        });

        if (!kioskResult.success) {
          return res.status(200).json({
            success: false,
            message: {
              en: "Failed to update kiosk balance",
              zh: "Êõ¥Êñ∞Kiosk‰ΩôÈ¢ùÂ§±Ë¥•",
            },
          });
        }
      }

      const formattedProcessTime = calculateProcessingTime(bonus.createdAt);

      bonus.status = "approved";
      bonus.processBy = adminuser.username;
      bonus.processtime = formattedProcessTime;
      await bonus.save();

      const updateFields = {
        $inc: {
          totalbonus: bonus.amount,
          wallet: bonus.amount,
        },
        $set: {
          ...(bonus.isLuckySpin && { luckySpinClaim: true }),
          ...(bonus.isCheckinBonus && { lastcheckinbonus: new Date() }),
        },
      };

      await User.findByIdAndUpdate(user._id, updateFields);

      const walletLog = await UserWalletLog.findOne({
        transactionid: bonus.transactionId,
        status: "pending",
      });

      if (walletLog) {
        walletLog.status = "approved";
        await walletLog.save();
      } else {
        console.error("UserWalletLog record not found for the bonus.");
      }

      await updateAverageProcessingTime(
        adminuser.username,
        bonus.processtime,
        "bonus"
      );
      res.status(200).json({
        success: true,
        message: {
          en: "Bonus approved successfully, wallet balance updated",
          zh: "Â•ñÈáëÂ∑≤ÊàêÂäüÊâπÂáÜÔºåÈí±ÂåÖ‰ΩôÈ¢ùÂ∑≤Êõ¥Êñ∞",
        },
      });
    } catch (error) {
      console.error("Error occurred while approving bonus:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Internal server error",
          zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
        },
      });
    }
  }
);

// Admin Reject Deposit
router.post(
  "/admin/api/rejectdeposit/:depositId",
  authenticateAdminToken,
  async (req, res) => {
    const { depositId } = req.params;
    const { rejectRemark } = req.body;
    const userId = req.user.userId;
    const adminuser = await adminUser.findById(userId);
    if (!adminuser) {
      return res.status(200).json({
        success: false,
        message: {
          en: "Admin User not found, please contact customer service",
          zh: "Êú™ÊâæÂà∞ÁÆ°ÁêÜÂëòÁî®Êà∑ÔºåËØ∑ËÅîÁ≥ªÂÆ¢Êà∑ÊúçÂä°",
        },
      });
    }
    try {
      const deposit = await Deposit.findById(depositId);
      if (!deposit) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Deposit record not found",
            zh: "Êâæ‰∏çÂà∞Â≠òÊ¨æËÆ∞ÂΩï",
          },
        });
      }
      if (deposit.status !== "pending") {
        return res.status(200).json({
          success: false,
          message: {
            en: "Deposit has been processed or status is incorrect",
            zh: "Â≠òÊ¨æÂ∑≤Â§ÑÁêÜÊàñÁä∂ÊÄÅ‰∏çÊ≠£Á°Æ",
          },
        });
      }

      const formattedProcessTime = calculateProcessingTime(deposit.createdAt);

      deposit.status = "rejected";
      deposit.processBy = adminuser.username;
      deposit.processtime = formattedProcessTime;
      deposit.remark = rejectRemark;
      await deposit.save();

      const walletLog = await UserWalletLog.findOne({
        transactionid: deposit.transactionId,
        status: "pending",
      });

      if (walletLog) {
        walletLog.status = "rejected";
        walletLog.promotionnameEN = rejectRemark;
        await walletLog.save();
      } else {
        console.error("UserWalletLog record not found for the deposit.");
      }

      await updateAverageProcessingTime(
        adminuser.username,
        deposit.processtime,
        "deposit"
      );

      res.status(200).json({
        success: true,
        message: {
          en: "Deposit rejected successfully",
          zh: "Â≠òÊ¨æÂ∑≤ÊàêÂäüÊãíÁªù",
        },
      });
    } catch (error) {
      console.error("Error occurred while rejecting deposit:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Internal server error",
          zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
        },
      });
    }
  }
);

// Admin Reject Withdraw
router.post(
  "/admin/api/rejectwithdraw/:withdrawId",
  authenticateAdminToken,
  async (req, res) => {
    const { withdrawId } = req.params;
    const { rejectRemark } = req.body;
    const userId = req.user.userId;
    const adminuser = await adminUser.findById(userId);
    if (!adminuser) {
      return res.status(200).json({
        success: false,
        message: {
          en: "Admin User not found, please contact customer service",
          zh: "Êú™ÊâæÂà∞ÁÆ°ÁêÜÂëòÁî®Êà∑ÔºåËØ∑ËÅîÁ≥ªÂÆ¢Êà∑ÊúçÂä°",
        },
      });
    }
    try {
      const withdraw = await Withdraw.findById(withdrawId);
      if (!withdraw) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Withdrawal record not found",
            zh: "Êâæ‰∏çÂà∞ÊèêÊ¨æËÆ∞ÂΩï",
          },
        });
      }

      if (withdraw.status !== "pending") {
        return res.status(200).json({
          success: false,
          message: {
            en: "Withdrawal has been processed or status is incorrect",
            zh: "ÊèêÊ¨æÂ∑≤Â§ÑÁêÜÊàñÁä∂ÊÄÅ‰∏çÊ≠£Á°Æ",
          },
        });
      }

      const user = await User.findOne({ username: withdraw.username });
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }

      const formattedProcessTime = calculateProcessingTime(withdraw.createdAt);

      user.wallet += withdraw.amount;
      await user.save();

      withdraw.status = "rejected";
      withdraw.processBy = adminuser.username;
      withdraw.processtime = formattedProcessTime;
      withdraw.remark = rejectRemark;
      await withdraw.save();

      const walletLog = await UserWalletLog.findOne({
        transactionid: withdraw.transactionId,
        status: "pending",
      });

      if (walletLog) {
        walletLog.status = "rejected";
        walletLog.promotionnameEN = rejectRemark;
        await walletLog.save();
      } else {
        console.error("UserWalletLog record not found for the Withdraw.");
      }

      await updateAverageProcessingTime(
        adminuser.username,
        withdraw.processtime,
        "withdrawal"
      );

      res.status(200).json({
        success: true,
        message: {
          en: "Withdrawal rejected successfully, wallet balance updated",
          zh: "ÊèêÊ¨æÂ∑≤ÊàêÂäüÊãíÁªùÔºåÈí±ÂåÖ‰ΩôÈ¢ùÂ∑≤Êõ¥Êñ∞",
        },
      });
    } catch (error) {
      console.error("Error occurred while rejecting withdrawal:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Internal server error",
          zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
        },
      });
    }
  }
);

// Admin Reject Bonus
router.post(
  "/admin/api/rejectbonus/:bonusId",
  authenticateAdminToken,
  async (req, res) => {
    const { bonusId } = req.params;
    const { rejectRemark } = req.body;
    const userId = req.user.userId;
    const adminuser = await adminUser.findById(userId);
    if (!adminuser) {
      return res.status(200).json({
        success: false,
        message: {
          en: "Admin User not found, please contact customer service",
          zh: "Êú™ÊâæÂà∞ÁÆ°ÁêÜÂëòÁî®Êà∑ÔºåËØ∑ËÅîÁ≥ªÂÆ¢Êà∑ÊúçÂä°",
        },
      });
    }
    try {
      const bonus = await Bonus.findById(bonusId);
      if (!bonus) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Bonus record not found",
            zh: "Êâæ‰∏çÂà∞Â•ñÈáëËÆ∞ÂΩï",
          },
        });
      }
      if (bonus.status !== "pending") {
        return res.status(200).json({
          success: false,
          message: {
            en: "Bonus has been processed or status is incorrect",
            zh: "Â•ñÈáëÂ∑≤Â§ÑÁêÜÊàñÁä∂ÊÄÅ‰∏çÊ≠£Á°Æ",
          },
        });
      }

      const formattedProcessTime = calculateProcessingTime(bonus.createdAt);

      bonus.status = "rejected";
      bonus.processBy = adminuser.username;
      bonus.processtime = formattedProcessTime;
      bonus.remark = rejectRemark;
      await bonus.save();

      const walletLog = await UserWalletLog.findOne({
        transactionid: bonus.transactionId,
        status: "pending",
      });

      if (walletLog) {
        walletLog.status = "rejected";
        walletLog.promotionnameEN = rejectRemark;
        await walletLog.save();
      } else {
        console.error("UserWalletLog record not found for the bonus.");
      }
      await updateAverageProcessingTime(
        adminuser.username,
        bonus.processtime,
        "bonus"
      );

      res.status(200).json({
        success: true,
        message: {
          en: "Bonus rejected successfully",
          zh: "Â•ñÈáëÂ∑≤ÊàêÂäüÊãíÁªù",
        },
      });
    } catch (error) {
      console.error("Error occurred while rejecting bonus:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Internal server error",
          zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
        },
      });
    }
  }
);

// Admin Revert Deposit
router.post(
  "/admin/api/revertdeposit/:depositId",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const { depositId } = req.params;
      const userId = req.user.userId;
      const adminuser = await adminUser.findById(userId);
      if (!adminuser) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Admin User not found, please contact customer service",
            zh: "Êú™ÊâæÂà∞ÁÆ°ÁêÜÂëòÁî®Êà∑ÔºåËØ∑ËÅîÁ≥ªÂÆ¢Êà∑ÊúçÂä°",
          },
        });
      }
      const deposit = await Deposit.findById(depositId);
      if (!deposit) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Deposit record not found",
            zh: "Êâæ‰∏çÂà∞Â≠òÊ¨æËÆ∞ÂΩï",
          },
        });
      }
      if (deposit.status !== "approved" || deposit.reverted) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Unable to revert this deposit",
            zh: "Êó†Ê≥ïÊí§ÈîÄÊ≠§Â≠òÊ¨æ",
          },
        });
      }
      const user = await User.findOne({ username: deposit.username });
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }
      if (user.wallet < deposit.amount) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Insufficient wallet balance for reversion",
            zh: "Èí±ÂåÖ‰ΩôÈ¢ù‰∏çË∂≥ÔºåÊó†Ê≥ïÊí§ÈîÄ",
          },
        });
      }

      let bank = null;

      if (deposit.method !== "auto") {
        bank = await BankList.findById(deposit.bankid);

        if (!bank) {
          return res.status(200).json({
            success: false,
            message: {
              en: "Bank account not found",
              zh: "Êâæ‰∏çÂà∞Èì∂Ë°åË¥¶Êà∑",
            },
          });
        }
      }

      const kioskSettings = await kioskbalance.findOne({});
      if (kioskSettings && kioskSettings.status) {
        const kioskResult = await updateKioskBalance("add", deposit.amount, {
          username: user.username,
          transactionType: "deposit reverted",
          remark: `Deposit ID: ${deposit._id}`,
          processBy: adminuser.username,
        });
        if (!kioskResult.success) {
          return res.status(200).json({
            success: false,
            message: {
              en: "Failed to update kiosk balance",
              zh: "Êõ¥Êñ∞Kiosk‰ΩôÈ¢ùÂ§±Ë¥•",
            },
          });
        }
      }

      if (
        user.firstDepositDate &&
        moment(deposit.createdAt).isSame(moment(user.firstDepositDate))
      ) {
        user.firstDepositDate = null;
        deposit.newDeposit = false;
      }

      const spinSetting = await LuckySpinSetting.findOne();
      if (spinSetting) {
        const spinCount = Math.floor(
          deposit.amount / spinSetting.depositAmount
        );
        if (user.luckySpinCount < spinCount) {
          return res.status(200).json({
            success: false,
            message: {
              en: "User does not have enough Lucky Spins to revert",
              zh: "Áî®Êà∑Ê≤°ÊúâË∂≥Â§üÁöÑÂπ∏ËøêËΩ¨ÁõòÊ¨°Êï∞ÂèØÊí§ÈîÄ",
            },
          });
        }
        user.luckySpinCount -= spinCount;
      }

      user.wallet -= deposit.amount;
      user.totaldeposit -= deposit.amount;
      await user.save();

      await checkAndUpdateVIPLevel(user._id);

      if (deposit.method !== "auto" && bank) {
        bank.currentbalance -= deposit.amount;
        bank.totalDeposits -= deposit.amount;
        await bank.save();
      }

      deposit.reverted = true;
      deposit.status = "reverted";
      deposit.revertedProcessBy = adminuser.username;
      await deposit.save();

      const walletLog = await UserWalletLog.findOne({
        transactionid: deposit.transactionId,
      });

      if (walletLog) {
        walletLog.status = "cancel";
        await walletLog.save();
      } else {
        console.error("UserWalletLog record not found for the deposit.");
      }

      adminuser.totalRevertedDeposits += 1;
      await adminuser.save();

      if (deposit.method !== "auto" && bank) {
        const transactionLog = new BankTransactionLog({
          bankName: bank.bankname,
          ownername: bank.ownername,
          remark: deposit.remark || "-",
          lastBalance: bank.currentbalance + deposit.amount,
          currentBalance: bank.currentbalance,
          processby: adminuser.username,
          transactiontype: "reverted deposit",
          amount: deposit.amount,
          qrimage: bank.qrimage,
          playerusername: user.username,
          playerfullname: user.fullname,
        });
        await transactionLog.save();
      }

      res.status(200).json({
        success: true,
        message: {
          en: "Deposit successfully reverted and user wallet updated",
          zh: "Â≠òÊ¨æÂ∑≤ÊàêÂäüÊí§ÈîÄÂπ∂Êõ¥Êñ∞Áî®Êà∑Èí±ÂåÖ",
        },
      });
    } catch (error) {
      console.error("Error during deposit reversion:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Internal server error",
          zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
        },
      });
    }
  }
);

// Admin Revert Withdraw
router.post(
  "/admin/api/revertwithdraw/:withdrawId",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const { withdrawId } = req.params;
      const userId = req.user.userId;
      const adminuser = await adminUser.findById(userId);
      if (!adminuser) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Admin User not found, please contact customer service",
            zh: "Êú™ÊâæÂà∞ÁÆ°ÁêÜÂëòÁî®Êà∑ÔºåËØ∑ËÅîÁ≥ªÂÆ¢Êà∑ÊúçÂä°",
          },
        });
      }
      const withdraw = await Withdraw.findById(withdrawId);
      if (!withdraw) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Withdrawal record not found",
            zh: "Êâæ‰∏çÂà∞ÊèêÊ¨æËÆ∞ÂΩï",
          },
        });
      }
      if (withdraw.status !== "approved" || withdraw.reverted) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Unable to revert this withdrawal",
            zh: "Êó†Ê≥ïÊí§ÈîÄÊ≠§ÊèêÊ¨æ",
          },
        });
      }
      const user = await User.findOne({ username: withdraw.username });
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }
      const bank = await BankList.findById(withdraw.withdrawbankid);
      if (!bank) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Bank account not found",
            zh: "Êâæ‰∏çÂà∞Èì∂Ë°åË¥¶Êà∑",
          },
        });
      }

      const kioskSettings = await kioskbalance.findOne({});
      if (kioskSettings && kioskSettings.status) {
        const kioskResult = await updateKioskBalance(
          "subtract",
          withdraw.amount,
          {
            username: user.username,
            transactionType: "withdraw reverted",
            remark: `Withdraw ID: ${withdraw._id}`,
            processBy: adminuser.username,
          }
        );
        if (!kioskResult.success) {
          return res.status(200).json({
            success: false,
            message: {
              en: "Failed to update kiosk balance",
              zh: "Êõ¥Êñ∞Kiosk‰ΩôÈ¢ùÂ§±Ë¥•",
            },
          });
        }
      }

      user.wallet += withdraw.amount;
      user.totalwithdraw -= withdraw.amount;
      await user.save();

      bank.currentbalance += withdraw.amount;
      bank.totalWithdrawals -= withdraw.amount;
      await bank.save();

      withdraw.reverted = true;
      withdraw.status = "reverted";
      withdraw.revertedProcessBy = adminuser.username;
      await withdraw.save();

      const walletLog = await UserWalletLog.findOne({
        transactionid: withdraw.transactionId,
      });

      if (walletLog) {
        walletLog.status = "cancel";
        await walletLog.save();
      } else {
        console.error("UserWalletLog record not found for the Withdraw.");
      }

      adminuser.totalRevertedWithdrawals += 1;
      await adminuser.save();

      const transactionLog = new BankTransactionLog({
        bankName: bank.bankname,
        ownername: bank.ownername,
        remark: withdraw.remark || "-",
        lastBalance: bank.currentbalance - withdraw.amount,
        currentBalance: bank.currentbalance,
        processby: adminuser.username,
        transactiontype: "reverted deposit",
        amount: withdraw.amount,
        qrimage: bank.qrimage,
        playerusername: user.username,
        playerfullname: user.fullname,
      });
      await transactionLog.save();

      res.status(200).json({
        success: true,
        message: {
          en: "Withdrawal successfully reverted and user wallet updated",
          zh: "ÊèêÊ¨æÂ∑≤ÊàêÂäüÊí§ÈîÄÂπ∂Êõ¥Êñ∞Áî®Êà∑Èí±ÂåÖ",
        },
      });
    } catch (error) {
      console.error("Error during withdrawal reversion:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Internal server error",
          zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
        },
      });
    }
  }
);

//Admin Revert Bonus
router.post(
  "/admin/api/revertbonus/:bonusId",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const { bonusId } = req.params;
      const userId = req.user.userId;
      const adminuser = await adminUser.findById(userId);
      if (!adminuser) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Admin User not found, please contact customer service",
            zh: "Êú™ÊâæÂà∞ÁÆ°ÁêÜÂëòÁî®Êà∑ÔºåËØ∑ËÅîÁ≥ªÂÆ¢Êà∑ÊúçÂä°",
          },
        });
      }
      const bonus = await Bonus.findById(bonusId);
      if (!bonus) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Bonus record not found",
            zh: "Êâæ‰∏çÂà∞Â•ñÈáëËÆ∞ÂΩï",
          },
        });
      }
      if (bonus.status !== "approved" || bonus.reverted) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Unable to revert this bonus",
            zh: "Êó†Ê≥ïÊí§ÈîÄÊ≠§Â•ñÈáë",
          },
        });
      }
      const user = await User.findOne({ username: bonus.username });
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }

      if (user.wallet < bonus.amount) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Insufficient wallet balance for reversion",
            zh: "Èí±ÂåÖ‰ΩôÈ¢ù‰∏çË∂≥ÔºåÊó†Ê≥ïÊí§ÈîÄ",
          },
        });
      }

      const kioskSettings = await kioskbalance.findOne({});
      if (kioskSettings && kioskSettings.status) {
        const kioskResult = await updateKioskBalance("add", bonus.amount, {
          username: user.username,
          transactionType: "bonus reverted",
          remark: `Bonus ID: ${bonus._id}`,
          processBy: adminuser.username,
        });
        if (!kioskResult.success) {
          return res.status(200).json({
            success: false,
            message: {
              en: "Failed to update kiosk balance",
              zh: "Êõ¥Êñ∞Kiosk‰ΩôÈ¢ùÂ§±Ë¥•",
            },
          });
        }
      }

      user.wallet -= bonus.amount;
      user.totalbonus -= bonus.amount;
      if (bonus.isLuckySpin) {
        user.luckySpinClaim = false;
      }
      if (bonus.isCheckinBonus) {
        user.lastcheckinbonus = null;
      }
      await user.save();

      bonus.reverted = true;
      bonus.status = "reverted";
      bonus.revertedProcessBy = adminuser.username;
      await bonus.save();

      const walletLog = await UserWalletLog.findOne({
        transactionid: bonus.transactionId,
      });
      if (walletLog) {
        walletLog.status = "cancel";
        await walletLog.save();
      } else {
        console.error("UserWalletLog record not found for the bonus.");
      }
      adminuser.totalRevertedBonuses += 1;
      await adminuser.save();

      res.status(200).json({
        success: true,
        message: {
          en: "Bonus successfully reverted and user wallet updated",
          zh: "Â•ñÈáëÂ∑≤ÊàêÂäüÊí§ÈîÄÂπ∂Êõ¥Êñ∞Áî®Êà∑Èí±ÂåÖ",
        },
      });
    } catch (error) {
      console.error("Error during bonus reversion:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Internal server error",
          zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
        },
      });
    }
  }
);

// Admin Search User
router.get(
  "/admin/api/search/:username",
  authenticateAdminToken,
  async (req, res) => {
    try {
      let username = req.params.username;
      const user = await User.findOne({ username: username });
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }
      res.status(200).json({
        success: true,
        data: {
          _id: user._id,
          username: user.username,
          balance: user.wallet,
          viplevel: user.viplevel,
          email: user.email,
          fullname: user.fullname,
        },
      });
    } catch (error) {
      console.error("Error searching user:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Error during user search",
          zh: "ÊêúÁ¥¢Áî®Êà∑Êó∂Âá∫Èîô",
        },
      });
    }
  }
);

// Admin Get Specific User Bank Accounts
router.get(
  "/admin/api/user/bankaccounts/:username",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const username = req.params.username;
      const user = await User.findOne({ username }).select("bankAccounts");
      if (!user || !user.bankAccounts) {
        return res.status(200).json({
          success: false,
          message: "No bank accounts found for this user",
        });
      }
      res.status(200).json({
        success: true,
        data: user.bankAccounts,
      });
    } catch (error) {
      console.error("Error fetching user bank accounts:", error);
      res.status(200).json({
        success: false,
        message: "Error fetching bank accounts",
      });
    }
  }
);

// Admin Update User Type
router.put(
  "/admin/api/user/:userId/type",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const userId = req.params.userId;
      const { userType } = req.body;

      const validTypes = ["", "followed", "agent", "not found"];
      if (!validTypes.includes(userType)) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Invalid user type",
            zh: "Êó†ÊïàÁöÑÁî®Êà∑Á±ªÂûã",
          },
        });
      }

      const user = await User.findById(userId);
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }

      const updateData = {};
      if (userType === "") {
        updateData.$unset = { userType: 1 };
      } else {
        updateData.$set = { userType: userType };
      }

      const updatedUser = await User.findByIdAndUpdate(userId, updateData, {
        new: true,
      });

      res.status(200).json({
        success: true,
        message: {
          en: "User type updated successfully",
          zh: "Áî®Êà∑Á±ªÂûãÊõ¥Êñ∞ÊàêÂäü",
        },
        data: {
          userType: updatedUser.userType || "",
        },
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: {
          en: "Error updating user type",
          zh: "Êõ¥Êñ∞Áî®Êà∑Á±ªÂûãÊó∂Âá∫Èîô",
        },
      });
    }
  }
);

// Admin Get ALl Users
router.get("/admin/api/allusers", authenticateAdminToken, async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const search = req.query.search || "";
    const sortKey = req.query.sortKey || "createdAt";
    const sortOrder = req.query.sortOrder || "desc";
    const skip = (page - 1) * limit;

    const query = search
      ? {
          $or: [
            { username: new RegExp(search, "i") },
            { fullname: new RegExp(search, "i") },
            { phonenumber: new RegExp(search, "i") },
          ],
        }
      : {};

    const sortKeyMap = {
      vipLevel: "viplevel",
      username: "username",
      fullname: "fullname",
      wallet: "walletAmount",
      verified: "isVerified",
      creationDate: "createdAt",
      lastLoginDate: "lastLogin",
      status: "status",
      totalDeposit: "totaldeposit",
      totalWithdraw: "totalwithdraw",
      winLose: "winlose",
    };

    // Optimized aggregation pipeline
    const pipeline = [
      // Match stage first for better performance
      { $match: query },

      // Computed fields stage
      {
        $addFields: {
          isVerified: {
            $or: ["$isPhoneVerified", "$isEmailVerified"],
          },
        },
      },

      {
        $addFields: {
          winlose: {
            $subtract: ["$totaldeposit", "$totalwithdraw"],
          },
          walletAmount: {
            $toDouble: "$wallet",
          },
        },
      },

      // Sorting stage
      {
        $sort: (() => {
          if (sortKey === "verified") {
            return {
              isVerified: sortOrder === "asc" ? 1 : -1,
              createdAt: -1,
            };
          }

          if (sortKey === "wallet") {
            return {
              walletAmount: sortOrder === "asc" ? 1 : -1,
              _id: 1,
            };
          }

          if (sortKey === "creationDate" || sortKey === "lastLoginDate") {
            const field = sortKeyMap[sortKey];
            return {
              [field]: sortOrder === "asc" ? 1 : -1,
              _id: 1, // Secondary sort for consistency
            };
          }

          return {
            [sortKeyMap[sortKey] || "createdAt"]: sortOrder === "asc" ? 1 : -1,
            _id: 1,
          };
        })(),
      },

      // Pagination
      { $skip: skip },
      { $limit: limit },

      // Project only needed fields
      {
        $project: {
          _id: 1,
          username: 1,
          fullname: 1,
          viplevel: 1,
          isPhoneVerified: 1,
          isEmailVerified: 1,
          phonenumber: 1,
          createdAt: 1,
          lastLogin: 1,
          lastLoginIp: 1,
          status: 1,
          duplicateIP: 1,
          isVerified: 1,
          totaldeposit: 1,
          totalwithdraw: 1,
          winlose: 1,
          wallet: "$walletAmount",
          userType: 1,
        },
      },
    ];

    const [users, totalUsers] = await Promise.all([
      User.aggregate(pipeline).allowDiskUse(true).exec(),
      User.countDocuments(query).lean(),
    ]);

    const totalPages = Math.ceil(totalUsers / limit);

    res.status(200).json({
      success: true,
      data: {
        users,
        pagination: {
          page,
          totalPages,
          totalUsers,
          limit,
          hasNextPage: page < totalPages,
          hasPrevPage: page > 1,
        },
      },
    });
  } catch (error) {
    console.error("Error fetching users:", error);
    res.status(500).json({
      success: false,
      message: "Error fetching all users",
      error: error.message,
    });
  }
});

// Admin Register User
router.post(
  "/admin/api/registeruser",
  authenticateAdminToken,
  async (req, res) => {
    const {
      username,
      fullname,
      email,
      dob,
      password,
      phonenumber,
      bankAccounts = [],
      referralCode,
    } = req.body;

    if (!username || !fullname || !password || !phonenumber) {
      return res.status(200).json({
        success: false,
        message: {
          en: "All fields are required",
          zh: "ÊâÄÊúâÂ≠óÊÆµÈÉΩÊòØÂøÖÂ°´ÁöÑ",
        },
      });
    }

    const normalizedUsername = username.toLowerCase();
    const normalizedFullname = fullname.toLowerCase().replace(/\s+/g, "");
    try {
      const existingUser = await User.findOne({
        $or: [
          { username: normalizedUsername },
          { fullname: new RegExp(`^${normalizedFullname}$`, "i") },
        ],
      });
      if (existingUser) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Duplicate User",
            zh: "Áî®Êà∑Â∑≤Â≠òÂú®",
          },
        });
      }
      const phoneToCheck = String(phonenumber);
      const alternativePhone = phoneToCheck.startsWith("60")
        ? "0" + phoneToCheck.substring(2)
        : phoneToCheck;
      const existingPhoneNumber = await User.findOne({
        $or: [{ phonenumber: phoneToCheck }, { phonenumber: alternativePhone }],
      });

      if (existingPhoneNumber) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Duplicate Phone Number",
            zh: "ÁîµËØùÂè∑Á†ÅÂ∑≤Â≠òÂú®",
          },
        });
      }
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(password, salt);
      const newReferralCode = await generateUniqueReferralCode();
      const referralLink = generateReferralLink(newReferralCode);
      const referralQrCode = await QRCode.toDataURL(referralLink);

      let referralBy = null;
      if (referralCode) {
        const referrer = await User.findOne({ referralCode: referralCode });
        if (referrer) {
          referralBy = {
            user_id: referrer._id,
            username: referrer.username,
          };
        }
      }

      const newUser = await User.create({
        username: normalizedUsername,
        fullname: normalizedFullname,
        email,
        dob,
        password: hashedPassword,
        phonenumber,
        bankAccounts,
        registerIp: "admin register",
        referralLink,
        referralCode: newReferralCode,
        referralQrCode,
        viplevel: "Bronze",
      });

      if (referralBy) {
        await User.findByIdAndUpdate(referralBy.user_id, {
          $push: {
            referrals: {
              user_id: newUser._id,
              username: newUser.username,
            },
          },
        });
      }

      res.status(200).json({
        success: true,
        message: {
          en: "User created successfully",
          zh: "Áî®Êà∑ÂàõÂª∫ÊàêÂäü",
        },
      });
    } catch (error) {
      console.error("Error occurred while creating user:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Internal server error",
          zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
        },
      });
    }
  }
);

// Admin Delete User
router.delete(
  "/admin/api/user/:userId",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const userId = req.params.userId;
      const adminId = req.user.userId;
      const adminuser = await adminUser.findById(adminId);
      if (!adminuser) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Admin User not found, please contact customer service",
            zh: "Êú™ÊâæÂà∞ÁÆ°ÁêÜÂëòÁî®Êà∑ÔºåËØ∑ËÅîÁ≥ªÂÆ¢Êà∑ÊúçÂä°",
          },
        });
      }
      const user = await User.findById(userId);
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }
      await User.findByIdAndDelete(userId);
      await adminLog.create({
        company: adminuser.company,
        username: adminuser.username,
        fullname: adminuser.fullname,
        loginTime: new Date(),
        ip: req.headers["x-forwarded-for"] || req.ip,
        remark: `Deleted user: ${user.username}`,
      });
      res.status(200).json({
        success: true,
        message: {
          en: "User has been deleted successfully",
          zh: "Áî®Êà∑Â∑≤ÊàêÂäüÂà†Èô§",
        },
      });
    } catch (error) {
      console.error("Error deleting user:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Internal server error",
          zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
        },
      });
    }
  }
);

// Admin Get Specific User Data
router.get(
  "/admin/api/user/:userId",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const userId = req.params.userId;
      const user = await User.findById(userId).select(
        " username totalturnover  fullname email phonenumber status viplevel bankAccounts wallet createdAt lastLogin lastLoginIp registerIp dob wallet withdrawlock rebate turnover winloss gamewallet rebate totaldeposit totalwithdraw lastdepositdate totalbonus gameStatus luckySpinCount remark referralCode referralBy duplicateIP gameStatus gameLock kiss918GameID kiss918GamePW pastKiss918GameID pastKiss918GamePW pussy888GameID pussy888GamePW pastPussy888GameID pastPussy888GamePW mega888GameID mega888GamePW pastMega888GameID pastMega888GamePW positionTaking"
      );
      if (!user) {
        return res.status(200).json({
          success: false,
          message: "User not found",
        });
      }
      return res.status(200).json({
        success: true,
        data: user,
      });
    } catch (error) {
      console.error("Error fetching user details:", error);
      return res.status(500).json({
        success: false,
        message: "Error fetching user details",
        error: error.message,
      });
    }
  }
);

// Admin Update Specific User Data
router.put(
  "/admin/api/user/:userId",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const userId = req.params.userId;
      const adminId = req.user.userId;
      const adminuser = await adminUser.findById(adminId);
      if (!adminuser) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Admin User not found, please contact customer service",
            zh: "Êú™ÊâæÂà∞ÁÆ°ÁêÜÂëòÁî®Êà∑ÔºåËØ∑ËÅîÁ≥ªÂÆ¢Êà∑ÊúçÂä°",
          },
        });
      }
      const {
        fullname,
        email,
        phonenumber,
        dob,
        viplevel,
        luckySpinCount,
        totalturnover,
        positionTaking,
        referralByUsername,
      } = req.body;

      let processedFullname = fullname;
      if (fullname) {
        processedFullname = fullname.trim().replace(/\s+/g, " ").toLowerCase();
      }

      const updatedUser = await User.findByIdAndUpdate(
        userId,
        {
          $set: {
            fullname: processedFullname,
            email,
            phonenumber: Number(phonenumber),
            dob,
            viplevel,
            luckySpinCount,
            totalturnover,
            positionTaking,
          },
        },
        { new: true }
      );
      if (!updatedUser) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }
      let clientIp = req.headers["x-forwarded-for"] || req.ip;
      clientIp = clientIp.split(",")[0].trim();
      if (referralByUsername !== undefined) {
        const currentReferralBy = updatedUser.referralBy
          ? updatedUser.referralBy.username
          : null;
        if (currentReferralBy !== referralByUsername) {
          const referralResult = await updateUserReferral(
            userId,
            referralByUsername,
            adminuser.username,
            adminuser.fullname,
            clientIp
          );
          if (!referralResult.success) {
            return res.status(200).json(referralResult);
          }
        }
      }
      res.status(200).json({
        success: true,
        message: {
          en: "User information updated successfully",
          zh: "Áî®Êà∑‰ø°ÊÅØÊõ¥Êñ∞ÊàêÂäü",
        },
        data: updatedUser,
      });
    } catch (error) {
      console.error("Error updating user:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Error updating user information",
          zh: "Êõ¥Êñ∞Áî®Êà∑‰ø°ÊÅØÊó∂Âá∫Èîô",
        },
      });
    }
  }
);

// Admin Update User Password
router.put(
  "/admin/api/user/:userId/password",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const userId = req.params.userId;
      const { password } = req.body;
      if (!password || password.length < 6) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Password must be at least 6 characters long",
            zh: "ÂØÜÁ†ÅÈïøÂ∫¶ÂøÖÈ°ªËá≥Â∞ë‰∏∫6‰∏™Â≠óÁ¨¶",
          },
        });
      }
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(password, salt);
      const updatedUser = await User.findByIdAndUpdate(
        userId,
        {
          $set: { password: hashedPassword },
        },
        { new: true }
      );
      if (!updatedUser) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }
      res.status(200).json({
        success: true,
        message: {
          en: "Password updated successfully",
          zh: "ÂØÜÁ†ÅÊõ¥Êñ∞ÊàêÂäü",
        },
      });
    } catch (error) {
      console.error("Error updating password:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Error updating password",
          zh: "Êõ¥Êñ∞ÂØÜÁ†ÅÊó∂Âá∫Èîô",
        },
      });
    }
  }
);

// Admnin Update User Status
router.put(
  "/admin/api/user/:userId/toggle-status",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const userId = req.params.userId;
      const user = await User.findById(userId);
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }
      const newStatus = user.status === true ? false : true;
      const updatedUser = await User.findByIdAndUpdate(
        userId,
        {
          $set: { status: newStatus },
        },
        { new: true }
      );
      res.status(200).json({
        success: true,
        message: {
          en: `User status updated to ${newStatus ? "active" : "inactive"}`,
          zh: `Áî®Êà∑Áä∂ÊÄÅÂ∑≤Êõ¥Êñ∞‰∏∫${newStatus ? "ÊøÄÊ¥ª" : "Á¶ÅÁî®"}`,
        },
        status: newStatus,
      });
    } catch (error) {
      console.error("Error updating status:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Error updating user status",
          zh: "Êõ¥Êñ∞Áî®Êà∑Áä∂ÊÄÅÊó∂Âá∫Èîô",
        },
      });
    }
  }
);

// Admin Update User Withdraw Lock
router.put(
  "/admin/api/user/:userId/toggle-withdraw-lock",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const userId = req.params.userId;
      const user = await User.findById(userId);
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }
      const newLockStatus = !user.withdrawlock;
      const updatedUser = await User.findByIdAndUpdate(
        userId,
        {
          $set: { withdrawlock: newLockStatus },
        },
        { new: true }
      );
      res.status(200).json({
        success: true,
        message: {
          en: newLockStatus
            ? "Withdraw lock for this user has been enabled"
            : "Withdraw lock for this user has been disabled",
          zh: newLockStatus
            ? "ËØ•Áî®Êà∑ÁöÑÊèêÊ¨æÈîÅÂÆöÂ∑≤ÂêØÁî®"
            : "ËØ•Áî®Êà∑ÁöÑÊèêÊ¨æÈîÅÂÆöÂ∑≤Á¶ÅÁî®",
        },
      });
    } catch (error) {
      console.error("Error toggling withdraw lock:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Error updating withdraw lock status",
          zh: "Êõ¥Êñ∞ÊèêÊ¨æÈîÅÂÆöÁä∂ÊÄÅÊó∂Âá∫Èîô",
        },
      });
    }
  }
);

// Admin Update User Duplicate IP
// router.put(
//   "/admin/api/user/:userId/toggle-duplicate-ip",
//   authenticateAdminToken,
//   async (req, res) => {
//     try {
//       const userId = req.params.userId;
//       const user = await User.findById(userId);
//       if (!user) {
//         return res.status(200).json({
//           success: false,
//           message: {
//             en: "User not found",
//             zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
//           },
//         });
//       }
//       const newDuplicateIPStatus = !user.duplicateIP;
//       const updatedUser = await User.findByIdAndUpdate(
//         userId,
//         {
//           $set: { duplicateIP: newDuplicateIPStatus },
//         },
//         { new: true }
//       );
//       res.status(200).json({
//         success: true,
//         message: {
//           en: newDuplicateIPStatus
//             ? "Duplicate IP status for this user has been enabled"
//             : "Duplicate IP status for this user has been disabled",
//           zh: newDuplicateIPStatus
//             ? "ËØ•Áî®Êà∑ÁöÑÈáçÂ§çIPÁä∂ÊÄÅÂ∑≤ÂêØÁî®"
//             : "ËØ•Áî®Êà∑ÁöÑÈáçÂ§çIPÁä∂ÊÄÅÂ∑≤Á¶ÅÁî®",
//         },
//       });
//     } catch (error) {
//       console.error("Error toggling Duplicate IP status:", error);
//       res.status(500).json({
//         success: false,
//         message: {
//           en: "Error updating duplicate IP status",
//           zh: "Êõ¥Êñ∞ÈáçÂ§çIPÁä∂ÊÄÅÊó∂Âá∫Èîô",
//         },
//       });
//     }
//   }
// );
router.put(
  "/admin/api/user/:userId/toggle-duplicate-ip",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const userId = req.params.userId;
      console.log("=== Toggle Duplicate IP Ë∞ÉËØï ===");
      const user = await User.findById(userId);
      if (!user) {
        console.log("ÈîôËØØ: Êâæ‰∏çÂà∞Áî®Êà∑ID‰∏∫", userId, "ÁöÑÁî®Êà∑");
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }

      console.log("ÊâæÂà∞Áî®Êà∑:");
      console.log("- Áî®Êà∑Âêç:", user.username);
      console.log("- ÂÖ®Âêç:", user.fullname);
      console.log("- ÂΩìÂâçduplicateIPÁä∂ÊÄÅ:", user.duplicateIP);

      const newDuplicateIPStatus = !user.duplicateIP;
      console.log("- Êñ∞ÁöÑduplicateIPÁä∂ÊÄÅ:", newDuplicateIPStatus);
      console.log("- Êìç‰ΩúÁ±ªÂûã:", newDuplicateIPStatus ? "ÂêØÁî®" : "Á¶ÅÁî®");

      const updatedUser = await User.findByIdAndUpdate(
        userId,
        {
          $set: { duplicateIP: newDuplicateIPStatus },
        },
        { new: true }
      );
      console.log("Êõ¥Êñ∞ÊàêÂäü:");
      console.log("- Êõ¥Êñ∞ÂêéduplicateIPÁä∂ÊÄÅ:", updatedUser.duplicateIP);
      console.log(
        "- Áä∂ÊÄÅÂèòÊõ¥Á°ÆËÆ§:",
        user.duplicateIP,
        "->",
        updatedUser.duplicateIP
      );
      console.log("=== ToggleÊìç‰ΩúÂÆåÊàê ===");

      res.status(200).json({
        success: true,
        message: {
          en: newDuplicateIPStatus
            ? "Duplicate IP status for this user has been enabled"
            : "Duplicate IP status for this user has been disabled",
          zh: newDuplicateIPStatus
            ? "ËØ•Áî®Êà∑ÁöÑÈáçÂ§çIPÁä∂ÊÄÅÂ∑≤ÂêØÁî®"
            : "ËØ•Áî®Êà∑ÁöÑÈáçÂ§çIPÁä∂ÊÄÅÂ∑≤Á¶ÅÁî®",
        },
      });
    } catch (error) {
      console.error("=== Toggle Duplicate IP ÈîôËØØ ===");
      console.error("ÈîôËØØËØ¶ÊÉÖ:", error);
      console.error("Áî®Êà∑ID:", req.params.userId);
      console.error("=== ÈîôËØØÁªìÊùü ===");

      res.status(500).json({
        success: false,
        message: {
          en: "Error updating duplicate IP status",
          zh: "Êõ¥Êñ∞ÈáçÂ§çIPÁä∂ÊÄÅÊó∂Âá∫Èîô",
        },
      });
    }
  }
);

// Admin Update User Remark
router.put(
  "/admin/api/user/:userId/remark",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const userId = req.params.userId;
      const { remark } = req.body;
      const updatedUser = await User.findByIdAndUpdate(
        userId,
        { $set: { remark } },
        { new: true }
      );
      if (!updatedUser) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }
      res.status(200).json({
        success: true,
        message: {
          en: "Remark updated successfully",
          zh: "Â§áÊ≥®Êõ¥Êñ∞ÊàêÂäü",
        },
      });
    } catch (error) {
      console.error("Error updating remark:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Error updating remark",
          zh: "Êõ¥Êñ∞Â§áÊ≥®Êó∂Âá∫Èîô",
        },
      });
    }
  }
);

// Admin Add User Bank Account
router.post(
  "/admin/api/user/:userId/bank-accounts",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const userId = req.params.userId;
      const { name, bankname, banknumber } = req.body;
      if (!name || !bankname || !banknumber) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Please provide all required bank account details",
            zh: "ËØ∑Êèê‰æõÊâÄÊúâÂøÖÈúÄÁöÑÈì∂Ë°åË¥¶Êà∑ËØ¶ÊÉÖ",
          },
        });
      }
      const user = await User.findById(userId);
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }
      user.bankAccounts.push({
        name,
        bankname,
        banknumber,
      });
      await user.save();
      res.status(200).json({
        success: true,
        message: {
          en: "Bank account added successfully",
          zh: "Èì∂Ë°åË¥¶Êà∑Ê∑ªÂä†ÊàêÂäü",
        },
        data: user.bankAccounts,
      });
    } catch (error) {
      console.error("Error adding bank account:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Error adding bank account",
          zh: "Ê∑ªÂä†Èì∂Ë°åË¥¶Êà∑Êó∂Âá∫Èîô",
        },
      });
    }
  }
);

// Admin Delete User Bank Account
router.delete(
  "/admin/api/user/:userId/bank-accounts/:bankId",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const { userId, bankId } = req.params;
      const user = await User.findById(userId);
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }
      const bankIndex = user.bankAccounts.findIndex(
        (bank) => bank._id.toString() === bankId
      );
      if (bankIndex === -1) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Bank account not found",
            zh: "Êâæ‰∏çÂà∞Èì∂Ë°åË¥¶Êà∑",
          },
        });
      }
      user.bankAccounts.splice(bankIndex, 1);
      await user.save();
      res.status(200).json({
        success: true,
        message: {
          en: "Bank account deleted successfully",
          zh: "Èì∂Ë°åË¥¶Êà∑Âà†Èô§ÊàêÂäü",
        },
        data: user.bankAccounts,
      });
    } catch (error) {
      console.error("Error deleting bank account:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Error deleting bank account",
          zh: "Âà†Èô§Èì∂Ë°åË¥¶Êà∑Êó∂Âá∫Èîô",
        },
      });
    }
  }
);

// Admin Get Active Bank Names
router.get(
  "/admin/api/activebanknames",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const activeBanks = await UserBankList.find(
        { isActive: true },
        "bankname"
      );
      res.json({
        success: true,
        data: activeBanks,
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message,
      });
    }
  }
);

// Admin Cashout User Wallet
router.patch(
  "/admin/api/user/cashout/:userId",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const userId = req.params.userId;
      const adminId = req.user.userId;
      const adminuser = await adminUser.findById(adminId);
      if (!adminuser) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Admin User not found, please contact customer service",
            zh: "Êâæ‰∏çÂà∞ÁÆ°ÁêÜÂëòÁî®Êà∑ÔºåËØ∑ËÅîÁ≥ªÂÆ¢Êúç",
          },
        });
      }
      const { amount, remark } = req.body;
      const user = await User.findById(userId);

      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }
      if (amount !== undefined) {
        if (amount > user.wallet) {
          return res.status(200).json({
            success: false,
            message: {
              en: "Withdrawal amount exceeds current wallet balance",
              zh: "ÊèêÊ¨æÈáëÈ¢ùË∂ÖËøáÂΩìÂâçÈí±ÂåÖ‰ΩôÈ¢ù",
            },
          });
        }
        const kioskSettings = await kioskbalance.findOne({});
        if (kioskSettings && kioskSettings.status) {
          const kioskResult = await updateKioskBalance("add", amount, {
            username: user.username,
            transactionType: "user cashout",
            remark: `Manual cashout`,
            processBy: adminuser.username,
          });
          if (!kioskResult.success) {
            return res.status(200).json({
              success: false,
              message: {
                en: "Failed to update kiosk balance",
                zh: "Êõ¥Êñ∞ÁΩëÁÇπ‰ΩôÈ¢ùÂ§±Ë¥•",
              },
            });
          }
        }
        user.wallet -= amount;
      }
      await user.save();

      const newCashOut = new UserWalletCashOut({
        transactionId: uuidv4(),
        userId: user._id,
        username: user.username,
        fullname: user.fullname,
        method: "manual",
        transactionType: "user cashout",
        processBy: adminuser.username,
        amount: amount,
        status: "approved",
        remark: remark,
      });
      await newCashOut.save();

      res.status(200).json({
        success: true,
        message: {
          en: "Wallet has been updated successfully",
          zh: "Èí±ÂåÖÂ∑≤ÊàêÂäüÊõ¥Êñ∞",
        },
      });
    } catch (error) {
      console.error("Error occurred while updating wallet:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Error processing cashout",
          zh: "Â§ÑÁêÜÊèêÁé∞Êó∂Âá∫Èîô",
        },
      });
    }
  }
);

// Admin Update User Rebate
router.patch(
  "/admin/api/user/:userId/updateRebate",
  authenticateAdminToken,
  async (req, res) => {
    const { userId } = req.params;
    const { rebate } = req.body;
    if (typeof rebate !== "number" || rebate < 0) {
      return res.status(200).json({
        success: false,
        message: {
          en: "Invalid rebate amount",
          zh: "Êó†ÊïàÁöÑËøîÂà©ÈáëÈ¢ù",
        },
      });
    }
    try {
      const user = await User.findById(userId);
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }
      user.rebate = rebate;
      await user.save();
      res.status(200).json({
        success: true,
        message: {
          en: "Rebate amount updated successfully",
          zh: "ËøîÂà©ÈáëÈ¢ùÊõ¥Êñ∞ÊàêÂäü",
        },
        rebate: user.rebate,
      });
    } catch (error) {
      console.error("Error updating rebate amount:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Error updating rebate amount",
          zh: "Êõ¥Êñ∞ËøîÂà©ÈáëÈ¢ùÊó∂Âá∫Èîô",
        },
      });
    }
  }
);

// Admin Get User Wallet Transfer Log
router.get(
  "/admin/api/user/walletransferlog/:userId",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const { userId } = req.params;
      const user = await User.findById(userId);
      if (!user) {
        return res.status(404).json({
          success: false,
          message: "User not found",
        });
      }
      const walletLogs = await adminUserWalletLog
        .find({ username: user.username })
        .sort({ createdAt: -1 });
      const processedLogs = walletLogs.map((log) => {
        let gameBalance = 0;
        const transferAmount = Math.abs(log.transferamount);
        if (log.transactiontype === "deposit") {
          gameBalance = log.userwalletbalance + transferAmount;
        }
        return {
          ...log.toObject(),
          gameBalance,
        };
      });

      // Return successful response
      res.status(200).json({
        success: true,
        message: "Wallet transfer logs retrieved successfully",
        data: processedLogs,
      });
    } catch (error) {
      console.error("Error retrieving wallet transfer logs:", error);
      res.status(500).json({
        success: false,
        message: "Failed to retrieve wallet transfer logs",
        error: error.message,
      });
    }
  }
);

// Admin Get User Logs
router.get("/admin/api/userlogs", authenticateAdminToken, async (req, res) => {
  try {
    const { startDate, endDate } = req.query;
    const dateFilter = {};
    if (startDate && endDate) {
      dateFilter.createdAt = {
        $gte: moment(new Date(startDate)).utc().toDate(),
        $lte: moment(new Date(endDate)).utc().toDate(),
      };
    }
    const adminId = req.user.userId;
    const admin = await adminUser.findById(adminId);
    if (!admin) {
      return res.status(404).json({
        success: false,
        message: "Admin user not found",
      });
    }
    const logs = await userLog
      .find({
        ...dateFilter,
      })
      .sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      message: "User logs retrieved successfully",
      data: logs,
    });
  } catch (error) {
    console.error("Error retrieving user logs:", error);
    res.status(500).json({
      success: false,
      message: "Failed to retrieve user logs",
      error: error.message,
    });
  }
});

// Admin Get Specific User Wallet Logs
router.get(
  "/admin/api/userwalletlog/:userId",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const { userId } = req.params;
      const { startDate, endDate } = req.query;
      const filter = { userId: userId };
      if (startDate && endDate) {
        filter.createdAt = {
          $gte: moment(new Date(startDate)).startOf("day").utc().toDate(),
          $lte: moment(new Date(endDate)).endOf("day").utc().toDate(),
        };
      }
      const userwalletlog = await UserWalletLog.find(filter).sort({
        createdAt: -1,
      });
      res.status(200).json({
        success: true,
        message: "User Wallet Log retrieved successfully",
        data: userwalletlog,
      });
    } catch (error) {
      console.error("Error occurred while retrieving User Wallet Log:", error);
      res.status(500).json({
        success: false,
        message: "Internal server error",
        error: error.message,
      });
    }
  }
);

// Update TelegramId & FacebookId
router.post("/api/updateSocialMedia", authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const user = await User.findById(userId);
    if (!user) {
      return res.status(200).json({
        success: false,
        message: {
          en: "User not found",
          zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
        },
      });
    }
    const { telegramId, facebookId, email } = req.body;
    if (email !== undefined) {
      user.email = email;
    }
    if (telegramId !== undefined) {
      user.telegramId = telegramId;
    }
    if (facebookId !== undefined) {
      user.facebookId = facebookId;
    }
    await user.save();
    res.status(200).json({
      success: true,
      message: {
        en: "Social media updated successfully",
        zh: "Á§æ‰∫§Â™í‰ΩìÊõ¥Êñ∞ÊàêÂäü",
      },
    });
  } catch (error) {
    console.error("Update social media error:", error);
    res.status(500).json({
      success: false,
      message: {
        en: "Internal server error",
        zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
      },
    });
  }
});

// Admin Get Summary Report
router.get(
  "/admin/api/summary-report",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      const dateFilter = {};
      if (startDate && endDate) {
        dateFilter.createdAt = {
          $gte: moment(new Date(startDate)).utc().toDate(),
          $lte: moment(new Date(endDate)).utc().toDate(),
        };
      }
      const [
        depositStats,
        withdrawStats,
        bonusStats,
        rebateStats,
        cashStats,
        cashoutStats,
        newDepositCount,
        revertedStats,
        newRegistrations,
      ] = await Promise.all([
        Deposit.aggregate([
          {
            $match: {
              status: "approved",
              reverted: false,
              ...dateFilter,
            },
          },
          {
            $group: {
              _id: null,
              depositQty: { $sum: 1 },
              totalDeposit: { $sum: "$amount" },
              uniquePlayers: { $addToSet: "$username" },
              totalProcessTime: {
                $sum: {
                  $add: [
                    {
                      $multiply: [
                        {
                          $convert: {
                            input: {
                              $arrayElemAt: [
                                { $split: ["$processtime", ":"] },
                                0,
                              ],
                            },
                            to: "int",
                            onError: 0,
                            onNull: 0,
                          },
                        },
                        3600,
                      ],
                    },
                    {
                      $multiply: [
                        {
                          $convert: {
                            input: {
                              $arrayElemAt: [
                                { $split: ["$processtime", ":"] },
                                1,
                              ],
                            },
                            to: "int",
                            onError: 0,
                            onNull: 0,
                          },
                        },
                        60,
                      ],
                    },
                    {
                      $convert: {
                        input: {
                          $arrayElemAt: [{ $split: ["$processtime", ":"] }, 2],
                        },
                        to: "int",
                        onError: 0,
                        onNull: 0,
                      },
                    },
                  ],
                },
              },
            },
          },
        ]),
        Withdraw.aggregate([
          {
            $match: {
              status: "approved",
              reverted: false,
              ...dateFilter,
            },
          },
          {
            $group: {
              _id: null,
              withdrawQty: { $sum: 1 },
              totalWithdraw: { $sum: "$amount" },
              totalProcessTime: {
                $sum: {
                  $add: [
                    {
                      $multiply: [
                        {
                          $convert: {
                            input: {
                              $arrayElemAt: [
                                { $split: ["$processtime", ":"] },
                                0,
                              ],
                            },
                            to: "int",
                            onError: 0,
                            onNull: 0,
                          },
                        },
                        3600,
                      ],
                    },
                    {
                      $multiply: [
                        {
                          $convert: {
                            input: {
                              $arrayElemAt: [
                                { $split: ["$processtime", ":"] },
                                1,
                              ],
                            },
                            to: "int",
                            onError: 0,
                            onNull: 0,
                          },
                        },
                        60,
                      ],
                    },
                    {
                      $convert: {
                        input: {
                          $arrayElemAt: [{ $split: ["$processtime", ":"] }, 2],
                        },
                        to: "int",
                        onError: 0,
                        onNull: 0,
                      },
                    },
                  ],
                },
              },
            },
          },
        ]),
        Bonus.aggregate([
          {
            $match: {
              status: "approved",
              reverted: false,
              ...dateFilter,
            },
          },
          {
            $group: {
              _id: null,
              totalBonus: { $sum: "$amount" },
            },
          },
        ]),
        RebateLog.aggregate([
          {
            $match: dateFilter,
          },
          {
            $group: {
              _id: null,
              totalRebate: { $sum: "$totalRebate" },
            },
          },
        ]),
        BankTransactionLog.aggregate([
          {
            $match: {
              transactiontype: { $in: ["cashin", "cashout"] },
              ...dateFilter,
            },
          },
          {
            $group: {
              _id: null,
              totalCashIn: {
                $sum: {
                  $cond: [
                    { $eq: ["$transactiontype", "cashin"] },
                    "$amount",
                    0,
                  ],
                },
              },
              totalCashOut: {
                $sum: {
                  $cond: [
                    { $eq: ["$transactiontype", "cashout"] },
                    "$amount",
                    0,
                  ],
                },
              },
            },
          },
        ]),
        UserWalletCashOut.aggregate([
          {
            $match: {
              status: "approved",
              reverted: false,
              ...dateFilter,
            },
          },
          {
            $group: {
              _id: null,
              cashoutQty: { $sum: 1 },
              totalCashout: { $sum: "$amount" },
            },
          },
        ]),
        Deposit.countDocuments({
          newDeposit: true,
          status: "approved",
          reverted: false,
          ...dateFilter,
        }),
        Promise.all([
          Deposit.countDocuments({ reverted: true, ...dateFilter }),
          Withdraw.countDocuments({ reverted: true, ...dateFilter }),
          Bonus.countDocuments({ reverted: true, ...dateFilter }),
          UserWalletCashOut.countDocuments({ reverted: true, ...dateFilter }),
        ]),
        User.countDocuments(dateFilter),
      ]);
      const reportData = {
        depositQty: depositStats[0]?.depositQty || 0,
        totalDeposit: depositStats[0]?.totalDeposit || 0,
        withdrawQty: withdrawStats[0]?.withdrawQty || 0,
        totalWithdraw: withdrawStats[0]?.totalWithdraw || 0,
        totalBonus: bonusStats[0]?.totalBonus || 0,
        totalRebate: rebateStats[0]?.totalRebate || 0,
        cashoutQty: cashoutStats[0]?.cashoutQty || 0,
        totalUserCashout: cashoutStats[0]?.totalCashout || 0,
        winLose:
          (depositStats[0]?.totalDeposit || 0) -
          (withdrawStats[0]?.totalWithdraw || 0),
        activePlayers: depositStats[0]?.uniquePlayers?.length || 0,
        newDeposits: newDepositCount || 0,
        newRegistrations: newRegistrations || 0,
        revertedTransactions:
          (revertedStats[0] || 0) +
          (revertedStats[1] || 0) +
          (revertedStats[2] || 0),
        totalCashIn: cashStats[0]?.totalCashIn || 0,
        totalCashOut: cashStats[0]?.totalCashOut || 0,
        avgDepositTime: depositStats[0]?.depositQty
          ? formatSeconds(
              Math.round(
                depositStats[0].totalProcessTime / depositStats[0].depositQty
              )
            )
          : "00:00:00",
        avgWithdrawTime: withdrawStats[0]?.withdrawQty
          ? formatSeconds(
              Math.round(
                withdrawStats[0].totalProcessTime / withdrawStats[0].withdrawQty
              )
            )
          : "00:00:00",
      };
      res.status(200).json({
        success: true,
        message: "Report data retrieved successfully",
        data: reportData,
      });
    } catch (error) {
      console.error("Error generating summary report:", error);
      res.status(200).json({
        success: false,
        message: "Internal server error",
        error: error.toString(),
      });
    }
  }
);

// Admin Get Player Report
router.get(
  "/admin/api/player-report",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const { startDate, endDate } = req.query;

      if (!startDate || !endDate) {
        return res.status(400).json({
          success: false,
          message: "Start date and end date are required",
        });
      }

      const today = moment.utc().format("YYYY-MM-DD");
      const startDateFormatted = moment(new Date(startDate))
        .utc()
        .add(8, "hours")
        .format("YYYY-MM-DD");
      const endDateFormatted = moment(new Date(endDate))
        .utc()
        .add(8, "hours")
        .format("YYYY-MM-DD");

      const needsTodayData = endDateFormatted >= today;
      const needsHistoricalData = startDateFormatted < today;

      const dateFilter = {};
      if (startDate && endDate) {
        dateFilter.createdAt = {
          $gte: moment(new Date(startDate)).utc().toDate(),
          $lte: moment(new Date(endDate)).utc().toDate(),
        };
      }

      // Run financial queries
      const financialResults = await Promise.all([
        Deposit.aggregate([
          {
            $match: {
              status: "approved",
              reverted: false,
              ...dateFilter,
            },
          },
          {
            $group: {
              _id: "$username",
              depositQty: { $sum: 1 },
              totalDeposit: { $sum: "$amount" },
            },
          },
        ]),

        Deposit.aggregate([
          {
            $match: {
              status: "approved",
              reverted: false,
              ...dateFilter,
            },
          },
          {
            $group: {
              _id: {
                username: "$username",
                date: {
                  $dateToString: {
                    format: "%Y-%m-%d",
                    date: {
                      $dateAdd: {
                        startDate: "$createdAt",
                        unit: "hour",
                        amount: 8,
                      },
                    },
                    timezone: "UTC",
                  },
                },
              },
            },
          },
          {
            $group: {
              _id: "$_id.username",
              uniqueDepositDays: { $sum: 1 },
            },
          },
        ]),

        Withdraw.aggregate([
          {
            $match: {
              status: "approved",
              reverted: false,
              ...dateFilter,
            },
          },
          {
            $group: {
              _id: "$username",
              withdrawQty: { $sum: 1 },
              totalWithdraw: { $sum: "$amount" },
            },
          },
        ]),

        Bonus.aggregate([
          {
            $match: {
              status: "approved",
              reverted: false,
              ...dateFilter,
            },
          },
          {
            $group: {
              _id: "$username",
              totalBonus: { $sum: "$amount" },
            },
          },
        ]),

        RebateLog.aggregate([
          {
            $match: dateFilter,
          },
          {
            $group: {
              _id: "$username",
              totalRebate: { $sum: "$totalRebate" },
            },
          },
        ]),

        UserWalletCashOut.aggregate([
          {
            $match: {
              reverted: false,
              ...dateFilter,
            },
          },
          {
            $group: {
              _id: "$username",
              totalCashout: { $sum: "$amount" },
            },
          },
        ]),
      ]);

      // Extract financial data
      const [
        depositStats,
        uniqueDepositStats,
        withdrawStats,
        bonusStats,
        rebateStats,
        cashoutStats,
      ] = financialResults;

      // Generic aggregation function for game turnover
      const getAllUsersTurnover = async (
        model,
        matchConditions,
        turnoverExpression = { $ifNull: ["$betamount", 0] }
      ) => {
        try {
          // Add date filter to match conditions
          const fullMatchConditions = {
            ...matchConditions,
            createdAt: dateFilter.createdAt,
          };

          const results = await model.aggregate([
            {
              $match: fullMatchConditions,
            },
            {
              $group: {
                _id: { $toLower: "$username" },
                turnover: { $sum: turnoverExpression },
              },
            },
          ]);

          return results.map((item) => ({
            username: item._id,
            turnover: Number(item.turnover.toFixed(2)),
          }));
        } catch (error) {
          console.error(
            `Error aggregating turnover for model ${model.modelName}:`,
            error
          );
          return [];
        }
      };

      // Process turnover data
      const userTurnoverMap = {};

      // Get historical data if needed
      if (needsHistoricalData) {
        const historicalData = await GameDataLog.find({
          date: {
            $gte: startDateFormatted,
            $lte:
              endDateFormatted < today
                ? endDateFormatted
                : moment.utc().subtract(1, "days").format("YYYY-MM-DD"),
          },
        });

        historicalData.forEach((record) => {
          const username = record.username.toLowerCase();

          if (!userTurnoverMap[username]) {
            userTurnoverMap[username] = 0;
          }

          // Convert gameCategories Map to Object if needed
          const gameCategories =
            record.gameCategories instanceof Map
              ? Object.fromEntries(record.gameCategories)
              : record.gameCategories;

          // Sum up turnover from all categories and games
          if (gameCategories) {
            Object.keys(gameCategories).forEach((categoryName) => {
              const category =
                gameCategories[categoryName] instanceof Map
                  ? Object.fromEntries(gameCategories[categoryName])
                  : gameCategories[categoryName];

              // Process each game in this category
              Object.keys(category).forEach((gameName) => {
                const game = category[gameName];
                const turnover = Number(game.turnover || 0);

                // Add to user total
                userTurnoverMap[username] += turnover;
              });
            });
          }
        });
      }

      // Get today's data if needed
      if (needsTodayData) {
        const todayGamePromises = [
          getAllUsersTurnover(SlotLivePPModal, {
            refunded: false,
            ended: true,
          }),
          getAllUsersTurnover(SlotLiveAGModal, {
            cancel: { $ne: true },
            settle: true,
          }),
          getAllUsersTurnover(SlotLiveGSCModal, {
            cancel: { $ne: true },
            settle: true,
          }),
          getAllUsersTurnover(
            SlotJokerModal,
            {
              cancel: { $ne: true },

              settle: true,
            },
            {
              $add: [
                { $ifNull: ["$betamount", 0] },
                { $ifNull: ["$fishTurnover", 0] },
              ],
            }
          ),
          getAllUsersTurnover(SlotJiliModal, {
            cancel: { $ne: true },

            settle: true,
          }),
          getAllUsersTurnover(SlotHabaneroModal, {
            refund: { $ne: true },

            settle: true,
          }),
          getAllUsersTurnover(SlotKiss918H5Modal, {
            cancel: { $ne: true },

            settle: true,
          }),
          getAllUsersTurnover(SlotCQ9Modal, {
            cancel: { $ne: true },
            refund: { $ne: true },
            settle: true,
          }),
          getAllUsersTurnover(SlotLive22Modal, {
            cancel: { $ne: true },

            settle: true,
          }),
          getAllUsersTurnover(SlotLiveMicroGamingModal, {
            cancel: { $ne: true },

            settle: true,
          }),
          getAllUsersTurnover(SlotUUSlotModal, {
            cancel: { $ne: true },

            settle: true,
          }),
          getAllUsersTurnover(LiveCT855Modal, {
            cancel: { $ne: true },
            settle: true,
          }),
          getAllUsersTurnover(
            PlaytechGameModal,
            {
              settle: true,
              cancel: { $ne: true },
            },
            { $ifNull: ["$betAmount", 0] }
          ),
          getAllUsersTurnover(SlotNextSpinModal, {
            cancel: { $ne: true },
            settle: true,
          }),
          getAllUsersTurnover(SlotLFC888Modal, {
            cancel: { $ne: true },
            settle: true,
          }),
          getAllUsersTurnover(SlotMega888H5Modal, {
            cancel: { $ne: true },
            settle: true,
          }),
          getAllUsersTurnover(LotteryAP95Modal, {}),
          getAllUsersTurnover(slotGW99Modal, {
            settle: true,
          }),
          getAllUsersTurnover(SlotSpadeGamingModal, {
            cancel: { $ne: true },
            settle: true,
          }),
          getAllUsersTurnover(SlotFachaiModal, {
            cancel: { $ne: true },
            settle: true,
          }),
          getAllUsersTurnover(LiveSaGamingModal, {
            cancel: { $ne: true },

            settle: true,
          }),
          getAllUsersTurnover(SlotHacksawModal, {
            cancel: { $ne: true },

            settle: true,
          }),
          getAllUsersTurnover(SportCMDModal, {
            cancel: { $ne: true },
          }),
        ];

        const todayGameResults = await Promise.allSettled(todayGamePromises);

        todayGameResults.forEach((gameResultPromise) => {
          if (gameResultPromise.status === "fulfilled") {
            const gameResults = gameResultPromise.value;

            gameResults.forEach((userResult) => {
              const username = userResult.username;
              if (!username) return;

              if (!userTurnoverMap[username]) {
                userTurnoverMap[username] = 0;
              }

              userTurnoverMap[username] += userResult.turnover || 0;
            });
          }
        });
      }

      // Get all unique usernames
      const usernames = new Set([
        ...depositStats.map((stat) => stat._id),
        ...uniqueDepositStats.map((stat) => stat._id),
        ...withdrawStats.map((stat) => stat._id),
        ...bonusStats.map((stat) => stat._id),
        ...rebateStats.map((stat) => stat._id),
        ...cashoutStats.map((stat) => stat._id),
        ...Object.keys(userTurnoverMap),
      ]);

      // Create report data
      const reportData = Array.from(usernames).map((username) => {
        const deposit =
          depositStats.find((stat) => stat._id === username) || {};
        const uniqueDeposit =
          uniqueDepositStats.find((stat) => stat._id === username) || {};
        const withdraw =
          withdrawStats.find((stat) => stat._id === username) || {};
        const bonus = bonusStats.find((stat) => stat._id === username) || {};
        const rebate = rebateStats.find((stat) => stat._id === username) || {};
        const cashout =
          cashoutStats.find((stat) => stat._id === username) || {};
        const totalTurnover = userTurnoverMap[username] || 0;

        return {
          username,
          depositQty: deposit.depositQty || 0,
          totalDeposit: deposit.totalDeposit || 0,
          uniqueDepositDays: uniqueDeposit.uniqueDepositDays || 0,
          withdrawQty: withdraw.withdrawQty || 0,
          totalWithdraw: withdraw.totalWithdraw || 0,
          totalBonus: bonus.totalBonus || 0,
          totalRebate: rebate.totalRebate || 0,
          totalCashout: cashout.totalCashout || 0,
          totalTurnover: Number(totalTurnover.toFixed(2)),
          winLose: (deposit.totalDeposit || 0) - (withdraw.totalWithdraw || 0),
        };
      });

      res.status(200).json({
        success: true,
        message: "Report data retrieved successfully",
        data: reportData,
        dateRange: {
          start: startDateFormatted,
          end: endDateFormatted,
        },
      });
    } catch (error) {
      console.error("Error generating user summary report:", error);
      res.status(500).json({
        success: false,
        message: "Internal server error",
        error: error.toString(),
      });
    }
  }
);

router.get(
  "/admin/api/user/:userId/gamewalletlog",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const { userId } = req.params;
      const user = await User.findById(userId);
      if (!user) {
        return res.status(404).json({
          success: false,
          message: "User not found",
        });
      }

      const { startDate, endDate } = req.query;

      const dateFilter = {
        username: user.username,
      };
      if (startDate && endDate) {
        dateFilter.createdAt = {
          $gte: moment(new Date(startDate)).utc().toDate(),
          $lte: moment(new Date(endDate)).utc().toDate(),
        };
      }

      const logs = await GameWalletLog.find(dateFilter)
        .sort({ createdAt: -1 })
        .lean();

      return res.status(200).json({
        success: true,
        message: "Game wallet log retrieved successfully",
        data: logs,
      });
    } catch (error) {
      console.error("Error generating game wallet log:", error);
      res.status(200).json({
        success: false,
        message: "Internal server error",
        error: error.toString(),
      });
    }
  }
);

// Get Today's Birthday Users (GMT+11)
router.get(
  "/admin/api/getTodayBirthdayUsers",

  async (req, res) => {
    try {
      const sydneyTime = moment().tz("Australia/Sydney");
      const todayMonth = sydneyTime.format("MM");
      const todayDay = sydneyTime.format("DD");
      const users = await User.find({
        dob: { $exists: true, $ne: null },
      }).select("username fullname dob");
      const birthdayUsers = users.filter((user) => {
        if (!user.dob) return false;
        const userBirthday = moment(user.dob, "DD/MM/YYYY");
        return (
          userBirthday.format("MM") === todayMonth &&
          userBirthday.format("DD") === todayDay
        );
      });
      const formattedUsers = birthdayUsers.map((user) => ({
        username: user.username,
        fullname: user.fullname,
        dob: user.dob,
      }));

      res.json({
        success: true,
        date: sydneyTime.format("DD/MM/YYYY"),
        timezone: "GMT+11 (Sydney)",
        birthdayUsers: formattedUsers,
      });
    } catch (error) {
      console.error("Error fetching birthday users:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch birthday users",
        error: error.message,
      });
    }
  }
);

// Get User Duplicate IP
router.get("/admin/api/users/find-by-ip/:ip", async (req, res) => {
  try {
    const { ip } = req.params;
    const users = await User.find(
      {
        $or: [{ lastLoginIp: ip }, { registerIp: ip }],
      },
      {
        username: 1,
        fullname: 1,
        lastLoginIp: 1,
        registerIp: 1,
        _id: 0,
      }
    );
    if (!users || users.length === 0) {
      return res.status(200).json({
        success: true,
        data: [],
        message: "No users found with this IP",
      });
    }
    const formattedUsers = users.map((user) => ({
      username: user.username,
      fullname: user.fullname,
      matchedWith: {
        lastLoginIp: user.lastLoginIp === ip,
        registerIp: user.registerIp === ip,
      },
    }));
    return res.status(200).json({
      success: true,
      data: formattedUsers,
      message: `Found ${users.length} user(s) with matching IP`,
    });
  } catch (error) {
    console.error("Error finding users by IP:", error);
    return res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
});

// Rescue Bonus
router.post(
  "/api/user/claim-rescue-bonus",
  authenticateToken,
  async (req, res) => {
    try {
      const userId = req.user.userId;
      const user = await User.findById(userId);
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Áî®Êà∑Êú™ÊâæÂà∞",
            ms: "Pengguna tidak dijumpai",
          },
        });
      }
      if (user.wallet >= 1) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Wallet balance must be less than $1.00 to claim rescue bonus",
            zh: "Èí±ÂåÖ‰ΩôÈ¢ùÂøÖÈ°ªÂ∞ë‰∫é$1.00ÊâçËÉΩÁî≥ËØ∑ÊïëÊè¥Â•ñÈáë",
            ms: "Baki dompet mestilah kurang daripada $1.00 untuk menuntut bonus penyelamat",
          },
        });
      }
      const malaysiaTimezone = "Asia/Kuala_Lumpur";
      const yesterdayStart = moment()
        .tz(malaysiaTimezone)
        .subtract(1, "day")
        .startOf("day")
        .utc();
      const yesterdayEnd = moment()
        .tz(malaysiaTimezone)
        .subtract(1, "day")
        .endOf("day")
        .utc();
      console.log(
        `Checking rescue bonus for ${user.username} on ${yesterdayStart.format(
          "YYYY-MM-DD"
        )}`
      );
      const [
        yesterdayDeposits,
        yesterdayBonuses,
        yesterdayWithdraws,
        yesterdayRebates,
      ] = await Promise.all([
        Deposit.find({
          userId: userId,
          status: "approved",
          reverted: false,
          createdAt: {
            $gte: yesterdayStart.toDate(),
            $lte: yesterdayEnd.toDate(),
          },
        }).lean(),
        Bonus.find({
          userId: userId,
          status: "approved",
          reverted: false,
          createdAt: {
            $gte: yesterdayStart.toDate(),
            $lte: yesterdayEnd.toDate(),
          },
        }).lean(),
        Withdraw.find({
          userId: userId,
          status: "approved",
          reverted: false,
          createdAt: {
            $gte: yesterdayStart.toDate(),
            $lte: yesterdayEnd.toDate(),
          },
        }).lean(),
        RebateLog.find({
          username: user.username,
          createdAt: {
            $gte: yesterdayStart.toDate(),
            $lte: yesterdayEnd.toDate(),
          },
        }).lean(),
      ]);
      const totalDeposit = yesterdayDeposits.reduce(
        (sum, deposit) => sum + parseFloat(deposit.amount || 0),
        0
      );
      const totalBonus = yesterdayBonuses.reduce(
        (sum, bonus) => sum + parseFloat(bonus.amount || 0),
        0
      );
      const totalWithdraw = yesterdayWithdraws.reduce(
        (sum, withdraw) => sum + parseFloat(withdraw.amount || 0),
        0
      );
      const totalRebate = yesterdayRebates.reduce(
        (sum, rebate) => sum + parseFloat(rebate.totalRebate || 0),
        0
      );
      const netLoss = totalDeposit - totalBonus - totalWithdraw - totalRebate;
      console.log(`Yesterday's calculation for ${user.username}:`);
      console.log(
        `Deposit: ${totalDeposit}, Bonus: ${totalBonus}, Withdraw: ${totalWithdraw}, Rebate: ${totalRebate}`
      );
      console.log(`Net Loss: ${netLoss}`);
      if (netLoss <= 0) {
        return res.status(200).json({
          success: false,
          message: {
            en: "No net loss yesterday, rescue bonus not available",
            zh: "Êò®Â§©Ê≤°ÊúâÂáÄÊçüÂ§±ÔºåÊó†Ê≥ïÁî≥ËØ∑ÊïëÊè¥Â•ñÈáë",
            ms: "Tiada kerugian bersih semalam, bonus penyelamat tidak tersedia",
          },
          calculationDetails: {
            totalDeposit: parseFloat(totalDeposit.toFixed(2)),
            totalBonus: parseFloat(totalBonus.toFixed(2)),
            totalWithdraw: parseFloat(totalWithdraw.toFixed(2)),
            totalRebate: parseFloat(totalRebate.toFixed(2)),
            netLoss: parseFloat(netLoss.toFixed(2)),
          },
        });
      }
      const rescueBonusAmount = parseFloat((netLoss * 0.05).toFixed(2));
      const todayStart = moment().tz(malaysiaTimezone).startOf("day").utc();
      const todayEnd = moment().tz(malaysiaTimezone).endOf("day").utc();
      const existingRescueBonus = await Bonus.findOne({
        userId: userId,
        promotionnameEN: "Rescue",
        createdAt: {
          $gte: todayStart.toDate(),
          $lte: todayEnd.toDate(),
        },
      });
      if (existingRescueBonus) {
        return res.status(200).json({
          success: false,
          message: {
            en: "You have already claimed rescue bonus today",
            zh: "ÊÇ®‰ªäÂ§©Â∑≤ÁªèÁî≥ËØ∑ËøáÊïëÊè¥Â•ñÈáë",
            ms: "Anda telah menuntut bonus penyelamat hari ini",
          },
        });
      }
      const promotionId = "683252a51c274350c235737c";
      const promotiondata = await promotion.findById(promotionId);
      if (!promotiondata) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Rescue bonus promotion not found",
            zh: "Êâæ‰∏çÂà∞ÊïëÊè¥Â•ñÈáë‰øÉÈîÄÊ¥ªÂä®",
            ms: "Promosi bonus penyelamat tidak dijumpai",
          },
        });
      }
      // const updatedUser = await User.findOneAndUpdate(
      //   { _id: userId },
      //   { $inc: { wallet: rescueBonusAmount } },
      //   { new: true }
      // );
      // if (!updatedUser) {
      //   return res.status(200).json({
      //     success: false,
      //     message: {
      //       en: "Failed to update wallet balance",
      //       zh: "Êõ¥Êñ∞Èí±ÂåÖ‰ΩôÈ¢ùÂ§±Ë¥•",
      //       ms: "Gagal mengemas kini baki dompet",
      //     },
      //   });
      // }
      const remark = `Deposit: $${totalDeposit.toFixed(
        2
      )}\nBonus: $${totalBonus.toFixed(2)}\nWithdraw: $${totalWithdraw.toFixed(
        2
      )}\nRebate: $${totalRebate.toFixed(2)}\nNet Loss: $${netLoss.toFixed(
        2
      )}\nRescue Bonus (5%): $${rescueBonusAmount}`;

      const transactionId = uuidv4();
      const NewBonusTransaction = new Bonus({
        transactionId: transactionId,
        userId: userId,
        username: user.username,
        fullname: user.fullname,
        transactionType: "bonus",
        processBy: "system",
        amount: rescueBonusAmount,
        walletamount: user.wallet,
        status: "pending",
        method: "manual",
        remark: remark,
        promotionname: promotiondata.maintitle,
        promotionnameEN: promotiondata.maintitleEN,
        promotionId: promotionId,
        processtime: "00:00:00",
      });
      await NewBonusTransaction.save();
      const walletLog = new UserWalletLog({
        userId: userId,
        transactionid: transactionId,
        transactiontime: new Date(),
        transactiontype: "bonus",
        amount: rescueBonusAmount,
        status: "pending",
        promotionnameCN: promotiondata.maintitle,
        promotionnameEN: promotiondata.maintitleEN,
      });
      await walletLog.save();
      console.log(
        `Rescue bonus ${rescueBonusAmount} credited to ${user.username}`
      );
      return res.status(200).json({
        success: true,
        message: {
          en: `Rescue bonus of $${rescueBonusAmount} has been submitted for approval`,
          zh: `ÊïëÊè¥Â•ñÈáë $${rescueBonusAmount} Â∑≤Êèê‰∫§Á≠âÂæÖÂÆ°Ê†∏`,
          ms: `Bonus penyelamat $${rescueBonusAmount} telah dihantar untuk kelulusan`,
        },
        rescueBonusAmount: rescueBonusAmount,
        calculationDetails: {
          totalDeposit: parseFloat(totalDeposit.toFixed(2)),
          totalBonus: parseFloat(totalBonus.toFixed(2)),
          totalWithdraw: parseFloat(totalWithdraw.toFixed(2)),
          totalRebate: parseFloat(totalRebate.toFixed(2)),
          netLoss: parseFloat(netLoss.toFixed(2)),
          rescuePercentage: 5,
        },
      });
    } catch (error) {
      console.error("Error claiming rescue bonus:", error);
      return res.status(500).json({
        success: false,
        message: {
          en: "Internal server error",
          zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
          ms: "Ralat pelayan dalaman",
        },
      });
    }
  }
);

// Admin Generate Magic Link
router.post(
  "/admin/api/user/:userId/generate-magic-link",
  authenticateAdminToken,
  async (req, res) => {
    try {
      const { userId } = req.params;
      const adminId = req.user.userId;
      const adminuser = await adminUser.findById(adminId);
      if (!adminuser) {
        return res.status(200).json({
          success: false,
          message: {
            en: "Admin User not found, please contact customer service",
            zh: "Êú™ÊâæÂà∞ÁÆ°ÁêÜÂëòÁî®Êà∑ÔºåËØ∑ËÅîÁ≥ªÂÆ¢Êà∑ÊúçÂä°",
          },
        });
      }
      const user = await User.findById(userId);
      if (!user) {
        return res.status(200).json({
          success: false,
          message: {
            en: "User not found",
            zh: "Êâæ‰∏çÂà∞Áî®Êà∑",
          },
        });
      }
      const token = crypto.randomBytes(32).toString("hex");
      const expires = new Date(Date.now() + 30 * 60 * 1000);
      user.adminMagicToken = token;
      user.adminMagicTokenExpires = expires;
      user.adminMagicTokenUsed = false;
      await user.save();

      let clientIp = req.headers["x-forwarded-for"] || req.ip;
      clientIp = clientIp.split(",")[0].trim();

      await adminLog.create({
        company: adminuser.company,
        username: adminuser.username,
        fullname: adminuser.fullname,
        loginTime: new Date(),
        ip: clientIp,
        remark: `Generated magic link for user: ${user.username}`,
      });

      const magicLink = `${process.env.FRONTEND_URL}magic-login?token=${token}`;

      res.status(200).json({
        success: true,
        magicLink: magicLink,
        expiresAt: expires,
        user: {
          username: user.username,
          fullname: user.fullname,
        },
        message: {
          en: `Magic link generated for user: ${user.username}`,
          zh: `Â∑≤‰∏∫Áî®Êà∑ ${user.username} ÁîüÊàêÈ≠îÊ≥ïÈìæÊé•`,
        },
      });
    } catch (error) {
      console.error("Generate admin magic link error:", error);
      res.status(500).json({
        success: false,
        message: {
          en: "Internal server error",
          zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
        },
      });
    }
  }
);

// Verify Magic Link
router.get("/api/verify-magic-link/:token", async (req, res) => {
  try {
    const { token } = req.params;
    const user = await User.findOne({
      adminMagicToken: token,
      adminMagicTokenExpires: { $gt: new Date() },
    });

    if (!user) {
      return res.status(400).json({
        success: false,
        message: {
          en: "Invalid or expired magic link",
          zh: "Êó†ÊïàÊàñÂ∑≤ËøáÊúüÁöÑÈ≠îÊ≥ïÈìæÊé•",
        },
      });
    }

    user.adminMagicTokenUsed = true;
    user.lastLogin = new Date();
    user.lastAdminAccess = new Date();
    await user.save();

    const {
      token: authToken,
      refreshToken,
      newGameToken,
    } = await handleLoginSuccess(user._id);

    let clientIp = req.headers["x-forwarded-for"] || req.ip;
    clientIp = clientIp.split(",")[0].trim();
    const geo = geoip.lookup(clientIp);

    await userLogAttempt(
      user.username,
      user.fullname,
      user.phonenumber,
      req.get("User-Agent"),
      clientIp,
      geo ? geo.country : "Unknown",
      geo ? geo.city : "Unknown",
      "Admin Magic Link Login Success"
    );

    res.status(200).json({
      success: true,
      token: authToken,
      refreshToken,
      newGameToken,
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        fullname: user.fullname,
      },
      message: {
        en: "Magic link login successful",
        zh: "È≠îÊ≥ïÈìæÊé•ÁôªÂΩïÊàêÂäü",
      },
    });
  } catch (error) {
    console.error("Verify admin magic link error:", error);
    res.status(500).json({
      success: false,
      message: {
        en: "Internal server error",
        zh: "ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ",
      },
    });
  }
});

module.exports = router;
module.exports.checkAndUpdateVIPLevel = checkAndUpdateVIPLevel;
